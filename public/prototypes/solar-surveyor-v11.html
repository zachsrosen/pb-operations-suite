<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Solar Surveyor V11: Energy Dispatch & Battery Simulation Suite</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg: #0f172a; --panel: #1e293b; --text: #f8fafc;
            --accent: #38bdf8; --success: #34d399; --err: #ef4444;
            --warn: #facc15; --purple: #a78bfa; --orange: #fb923c;
        }
        * { box-sizing: border-box; }
        body { margin: 0; padding: 15px; background: var(--bg); color: var(--text); font-family: -apple-system, system-ui, sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #334155; padding-bottom: 12px; margin-bottom: 15px; flex-shrink: 0; }
        h1 { margin: 0; font-size: 18px; font-weight: 700; color: white; display: flex; align-items: center; gap: 8px; }
        .badge { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; padding: 4px 10px; border-radius: 4px; font-size: 11px; font-weight: bold; }
        #mode-badge { font-size: 11px; font-weight: bold; color: #94a3b8; border: 1px solid #334155; padding: 4px 8px; border-radius: 4px; }

        .layout { display: grid; grid-template-columns: 300px 1fr 340px; gap: 15px; height: 100%; overflow: hidden; }
        .sidebar { display: flex; flex-direction: column; gap: 12px; overflow-y: auto; padding-right: 5px; }
        .stage { background: #000; border: 1px solid #334155; border-radius: 8px; position: relative; overflow: hidden; display: flex; flex-direction: column; }
        .right-panel { display: flex; flex-direction: column; gap: 12px; overflow-y: auto; }

        .card { background: var(--panel); border: 1px solid #334155; border-radius: 8px; padding: 12px; }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .lbl { font-size: 10px; font-weight: 700; color: #94a3b8; text-transform: uppercase; margin-bottom: 6px; display: block; }

        .file-box { position: relative; border: 1px dashed #475569; padding: 10px; border-radius: 6px; text-align: center; margin-bottom: 8px; transition: 0.2s; cursor: pointer; font-size: 12px; }
        .file-box:hover { border-color: var(--accent); background: rgba(56, 189, 248, 0.1); }
        .file-box input { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
        .file-box.done { border-color: var(--success); color: var(--success); font-weight: bold; background: rgba(52, 211, 153, 0.1); }
        .opt { font-size: 9px; color: #64748b; font-weight: normal; margin-left: 4px; }

        button { width: 100%; padding: 12px; background: var(--accent); color: #0f172a; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; text-transform: uppercase; font-size: 11px; }
        button:hover { filter: brightness(1.1); }
        button:disabled { background: #334155; color: #94a3b8; cursor: not-allowed; }
        .btn-sm { padding: 6px 10px; font-size: 10px; width: auto; }
        .btn-secondary { background: #475569; color: white; }
        .btn-success { background: var(--success); }
        .btn-purple { background: var(--purple); }
        .btn-danger { background: var(--err); }

        .stat-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px; }
        .stat-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-bottom: 8px; }
        .stat-item { background: rgba(0,0,0,0.3); padding: 8px; border: 1px solid #334155; border-radius: 4px; }
        .stat-val { font-size: 16px; font-weight: 700; color: white; display: block; }
        .stat-val-sm { font-size: 13px; font-weight: 700; color: white; display: block; }
        .stat-name { font-size: 9px; color: #94a3b8; text-transform: uppercase; }

        #log { font-family: monospace; font-size: 10px; color: #94a3b8; background: #000; padding: 8px; height: 100px; overflow-y: auto; border: 1px solid #334155; border-radius: 6px; white-space: pre-wrap; }
        .ln-ok { color: var(--success); } .ln-err { color: var(--err); } .ln-warn { color: var(--warn); }

        .tabs { display: flex; border-bottom: 1px solid #334155; background: var(--panel); flex-wrap: wrap; }
        .tab-btn { padding: 10px 14px; background: none; border: none; color: #94a3b8; font-size: 11px; font-weight: 600; cursor: pointer; border-right: 1px solid #334155; width: auto; }
        .tab-btn.active { background: var(--accent); color: #0f172a; }
        .tab-btn:hover:not(.active) { background: rgba(255,255,255,0.05); }

        .view-pane { display: none; height: 100%; width: 100%; position: relative; flex-direction: column; overflow: hidden; }
        .view-pane.active { display: flex; }

        #svgRender { width: 100%; height: 100%; cursor: crosshair; }
        .poly-panel { fill: rgba(59, 130, 246, 0.15); stroke: #3b82f6; stroke-width: 0.8; cursor: pointer; transition: all 0.15s; }
        .poly-panel:hover { fill: rgba(59, 130, 246, 0.4); stroke-width: 1.5; }
        .poly-panel.selected { fill: rgba(52, 211, 153, 0.4); stroke: var(--success); stroke-width: 1.5; }
        .poly-panel.strung { stroke-width: 1.2; }
        .pt-rad { r: 0.5px; transition: fill 0.1s; pointer-events: none; }
        .lbl-id { font-size: 3px; fill: white; text-anchor: middle; dominant-baseline: middle; pointer-events: none; font-weight: bold; }
        .string-line { stroke-width: 0.4; fill: none; opacity: 0.8; }

        .hud-panel { position: absolute; bottom: 15px; left: 15px; width: 220px; background: rgba(15, 23, 42, 0.95); border: 1px solid #334155; border-radius: 8px; padding: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); z-index: 10; }
        .slide-lbl { display: flex; justify-content: space-between; font-size: 10px; color: #94a3b8; margin-bottom: 4px; }
        input[type="range"] { width: 100%; cursor: pointer; margin-bottom: 8px; }
        input[type="range"]:disabled { opacity: 0.5; cursor: not-allowed; }

        .string-mode-hud { position: absolute; top: 15px; left: 15px; background: rgba(15, 23, 42, 0.95); border: 1px solid var(--purple); border-radius: 8px; padding: 12px; z-index: 10; min-width: 200px; }
        .string-mode-hud.hidden { display: none; }

        select { width: 100%; padding: 8px; background: #0f172a; color: white; border: 1px solid #475569; border-radius: 4px; font-size: 11px; margin-bottom: 8px; }
        input[type="number"] { width: 100%; padding: 6px; background: #0f172a; color: white; border: 1px solid #475569; border-radius: 4px; font-size: 11px; }

        .string-list { max-height: 200px; overflow-y: auto; }
        .string-item { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: rgba(0,0,0,0.3); border: 1px solid #334155; border-radius: 4px; margin-bottom: 4px; font-size: 11px; cursor: pointer; }
        .string-item:hover { background: rgba(255,255,255,0.05); }
        .string-item.active { border-color: var(--purple); background: rgba(167, 139, 250, 0.15); }
        .string-color { width: 12px; height: 12px; border-radius: 2px; margin-right: 8px; }

        .inv-card { background: rgba(0,0,0,0.3); border: 1px solid #475569; border-radius: 6px; padding: 10px; margin-bottom: 8px; }
        .inv-header { display: flex; justify-content: space-between; font-size: 12px; font-weight: 600; margin-bottom: 6px; }
        .inv-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 10px; }
        .inv-stat { background: rgba(0,0,0,0.3); padding: 4px 6px; border-radius: 3px; }
        .clip-warn { color: var(--warn); font-weight: bold; }
        .clip-ok { color: var(--success); }

        .prod-table { width: 100%; border-collapse: collapse; font-size: 10px; color: #cbd5e1; }
        .prod-table th { text-align: left; padding: 6px 5px; border-bottom: 1px solid #475569; color: #94a3b8; position: sticky; top: 0; background: #000; font-size: 9px; }
        .prod-table td { padding: 4px 5px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .prod-table tr:hover { background: rgba(255,255,255,0.05); }
        .prod-table tfoot td { border-top: 2px solid #475569; font-weight: bold; padding: 8px 5px; }

        .chart-container { height: 250px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 6px; margin: 10px; position: relative; }
        .chart-bar { position: absolute; bottom: 30px; background: linear-gradient(to top, var(--accent), var(--purple)); border-radius: 2px 2px 0 0; min-width: 2px; }
        .chart-clip { background: linear-gradient(to top, var(--warn), var(--orange)) !important; }
        .chart-label { position: absolute; bottom: 5px; font-size: 8px; color: #64748b; transform: rotate(-45deg); transform-origin: top left; }
        .chart-axis { position: absolute; left: 10px; bottom: 30px; top: 10px; width: 1px; background: #475569; }
        .chart-limit-line { position: absolute; left: 10px; right: 10px; height: 1px; border-top: 1px dashed var(--err); z-index: 5; }
        .chart-limit-label { position: absolute; right: 5px; font-size: 8px; color: var(--err); transform: translateY(-12px); }

        .recommendation-card { background: rgba(167, 139, 250, 0.1); border: 1px solid var(--purple); border-radius: 6px; padding: 12px; margin-bottom: 10px; }
        .rec-header { display: flex; align-items: center; gap: 8px; font-size: 12px; font-weight: 600; color: var(--purple); margin-bottom: 8px; }
        .rec-body { font-size: 11px; color: #cbd5e1; line-height: 1.5; }
        .issue-item { display: flex; align-items: flex-start; gap: 6px; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .issue-icon { font-size: 14px; }

        #tooltip { position: fixed; display: none; background: rgba(15,23,42,0.95); padding: 10px; border: 1px solid #475569; border-radius: 4px; font-size: 11px; pointer-events: none; z-index: 100; color: white; max-width: 280px; }

        .clip-log-table { width: 100%; border-collapse: collapse; font-size: 10px; margin-top: 10px; }
        .clip-log-table th { text-align: left; padding: 6px; border-bottom: 1px solid #475569; color: #94a3b8; font-size: 9px; }
        .clip-log-table td { padding: 4px 6px; border-bottom: 1px solid rgba(255,255,255,0.05); color: #cbd5e1; }
        .clip-log-table tr:hover { background: rgba(255,255,255,0.05); }
        .clip-severity-high { color: var(--err); }
        .clip-severity-med { color: var(--warn); }
        .clip-severity-low { color: var(--success); }

        .inv-cfg-item { background: rgba(0,0,0,0.3); border: 1px solid #475569; border-radius: 6px; padding: 8px; margin-bottom: 6px; font-size: 11px; }
        .inv-cfg-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        .inv-cfg-channels { padding-left: 8px; }
        .inv-cfg-channel { padding: 3px 0; color: #94a3b8; font-size: 10px; }
        .inv-cfg-assign { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 4px; }
        .inv-cfg-assign .tag { background: rgba(56,189,248,0.2); border: 1px solid var(--accent); padding: 2px 6px; border-radius: 3px; font-size: 9px; cursor: pointer; }
        .inv-cfg-assign .tag:hover { background: rgba(239,68,68,0.3); border-color: var(--err); }
        .inv-unassigned { color: var(--warn); font-size: 10px; padding: 4px; }
    </style>
</head>
<body>

<header>
    <h1>Solar Surveyor <span class="badge">V11</span></h1>
    <div style="display:flex; gap:10px; align-items:center;">
        <div id="mode-badge">WAITING</div>
    </div>
</header>

<div class="layout">
    <!-- LEFT SIDEBAR -->
    <div class="sidebar">
        <div class="card">
            <span class="lbl">1. Data Import</span>
            <div class="file-box" id="boxGeo"><span id="txtGeo">JSON Layout</span><input type="file" accept=".json" onchange="APP.loadGeo(this)"></div>
            <div class="file-box" id="boxRad"><span id="txtRad">Radiance DXF</span><input type="file" accept=".dxf" onchange="APP.loadRad(this)"></div>
            <div class="file-box" id="boxZip"><span id="txtZip">Shading ZIP/CSVs</span><input type="file" accept=".zip,.csv" multiple onchange="APP.handleData(this)"></div>
            <button id="btnRun" onclick="APP.process()" disabled>Run Analysis</button>
        </div>

        <div class="card">
            <span class="lbl">2. Equipment Profiles</span>
            <label style="font-size:10px; color:#94a3b8;">Panel</label>
            <select id="selPanel" onchange="APP.updateEquipment()"></select>
            <label style="font-size:10px; color:#94a3b8;">Inverter</label>
            <select id="selInverter" onchange="APP.updateEquipment()"></select>
            <label style="font-size:10px; color:#94a3b8;">ESS/Battery</label>
            <select id="selESS" onchange="APP.updateEquipment()"></select>
            <div style="margin-top:8px; padding:8px; background:rgba(0,0,0,0.3); border-radius:4px; font-size:10px;">
                <div id="equipSummary">Select equipment to see specs</div>
            </div>
        </div>

        <div class="card">
            <span class="lbl">3. Site Conditions</span>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px;">
                <div>
                    <label style="font-size:10px; color:#94a3b8;">Min Temp (&deg;C)</label>
                    <input type="number" id="tempMin" value="-20" onchange="APP.recalcStrings()">
                </div>
                <div>
                    <label style="font-size:10px; color:#94a3b8;">Max Temp (&deg;C)</label>
                    <input type="number" id="tempMax" value="45" onchange="APP.recalcStrings()">
                </div>
            </div>
            <div>
                <div class="slide-lbl"><span>Clipping Threshold</span><span id="lblClipThresh">100%</span></div>
                <input type="range" id="rngClipThresh" min="0" max="200" value="100" step="1" oninput="APP.updateClipThreshold()">
                <div style="font-size:9px; color:#64748b;">Flag clipping when DC*eff exceeds this % of AC rating</div>
            </div>
            <div style="margin-top:8px;">
                <label style="font-size:10px; color:#94a3b8;">AC Export Limit (kW)</label>
                <input type="number" id="acExportLimit" value="0" min="0" step="0.1" onchange="APP.updateExportLimit()" placeholder="0 = no limit">
                <div style="font-size:9px; color:#64748b; margin-top:2px;">System curtailment. 0 = unlimited.</div>
            </div>
        </div>

        <div class="card">
            <span class="lbl">4. Home Consumption</span>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-bottom:8px;">
                <div>
                    <label style="font-size:9px; color:#94a3b8;">Zip Code</label>
                    <input type="text" id="consumeZipCode" maxlength="5" placeholder="e.g. 85281" style="width:100%; padding:5px; background:#0f172a; color:white; border:1px solid #475569; border-radius:4px; font-size:11px;" onchange="APP.updateConsumption()">
                </div>
                <div>
                    <label style="font-size:9px; color:#94a3b8;">Home Sq Ft</label>
                    <input type="number" id="consumeSqFt" value="0" min="0" step="100" placeholder="e.g. 2000" style="width:100%; padding:5px; background:#0f172a; color:white; border:1px solid #475569; border-radius:4px; font-size:11px;" onchange="APP.updateConsumption()">
                </div>
            </div>
            <div style="display:flex; gap:8px; margin-bottom:8px;">
                <label style="font-size:10px; cursor:pointer; display:flex; align-items:center; gap:3px;">
                    <input type="radio" name="consumeMethod" value="annual" checked onchange="APP.setConsumptionMethod('annual')"> Annual kWh
                </label>
                <label style="font-size:10px; cursor:pointer; display:flex; align-items:center; gap:3px;">
                    <input type="radio" name="consumeMethod" value="monthly" onchange="APP.setConsumptionMethod('monthly')"> Monthly CSV
                </label>
            </div>
            <div id="consumeAnnualInput">
                <input type="number" id="annualConsumption" value="0" min="0" step="100" placeholder="Annual kWh (e.g. 12000)" onchange="APP.updateConsumption()">
                <div style="font-size:9px; color:#64748b; margin-top:2px;">Enter yearly usage. 0 = disabled.</div>
            </div>
            <div id="consumeMonthlyInput" style="display:none;">
                <div class="file-box" id="boxConsumption">
                    <span id="txtConsumption">Monthly kWh CSV</span>
                    <input type="file" accept=".csv" onchange="APP.loadConsumptionCSV(this)">
                </div>
                <div style="font-size:9px; color:#64748b; margin-top:2px;">CSV with 12 monthly kWh values (Jan-Dec)</div>
            </div>
            <div style="margin-top:8px;">
                <label style="font-size:10px; color:#94a3b8;">Priority Mode</label>
                <select id="selPriorityMode" onchange="APP.updatePriorityMode()">
                    <option value="self">Self-Consumption (home first)</option>
                    <option value="tou">Time-of-Use (rate optimized)</option>
                    <option value="export">Export-First (grid priority)</option>
                </select>
            </div>
            <div style="margin-top:8px;">
                <label style="font-size:10px; color:#94a3b8;">Backup Reserve: <strong id="lblReservePct">20</strong>%</label>
                <input type="range" id="sliderReserve" min="0" max="80" value="20" step="5"
                       oninput="document.getElementById('lblReservePct').innerText=this.value; APP.homeConsumption.backupReservePct=parseInt(this.value); if(APP.stringTimeseries.length>0){APP.runEnergyDispatch();APP.renderInverterView();APP.renderBatteryView();APP.renderTimeseries();}">
                <div style="display:flex; justify-content:space-between; font-size:8px; color:#64748b; margin-top:-4px;">
                    <span>0% (Max usage)</span><span>80% (Backup only)</span>
                </div>
            </div>
            <div style="margin-top:8px; display:grid; grid-template-columns:1fr 1fr 1fr; gap:4px;">
                <div>
                    <label style="font-size:8px; color:#64748b;">Standard $/kWh</label>
                    <input type="number" id="rateStandard" value="0.14" min="0" max="1" step="0.01" style="width:100%; padding:3px; background:#0f172a; color:white; border:1px solid #475569; border-radius:3px; font-size:10px;" onchange="APP.utilityRates.standard=parseFloat(this.value)||0.14">
                </div>
                <div>
                    <label style="font-size:8px; color:#64748b;">Peak $/kWh</label>
                    <input type="number" id="ratePeak" value="0.35" min="0" max="1" step="0.01" style="width:100%; padding:3px; background:#0f172a; color:white; border:1px solid #475569; border-radius:3px; font-size:10px;" onchange="APP.utilityRates.peak=parseFloat(this.value)||0.35">
                </div>
                <div>
                    <label style="font-size:8px; color:#64748b;">Off-Peak $/kWh</label>
                    <input type="number" id="rateOffPeak" value="0.10" min="0" max="1" step="0.01" style="width:100%; padding:3px; background:#0f172a; color:white; border:1px solid #475569; border-radius:3px; font-size:10px;" onchange="APP.utilityRates.offPeak=parseFloat(this.value)||0.10">
                </div>
            </div>
            <div id="consumptionSummary" style="margin-top:8px; padding:6px; background:rgba(0,0,0,0.3); border-radius:4px; font-size:10px; display:none;"></div>
        </div>

        <div class="card" style="flex:1; display:flex; flex-direction:column;">
            <span class="lbl">System Log</span>
            <div id="log">Ready. Load data to begin.</div>
        </div>
    </div>

    <!-- MAIN STAGE -->
    <div class="stage">
        <div class="tabs">
            <button class="tab-btn active" onclick="APP.tab('map', this)">Visualizer</button>
            <button class="tab-btn" onclick="APP.tab('string', this)">Stringing</button>
            <button class="tab-btn" onclick="APP.tab('prod', this)">Production</button>
            <button class="tab-btn" onclick="APP.tab('ts', this)">30-Min Series</button>
            <button class="tab-btn" onclick="APP.tab('inverter', this)">Inverters</button>
            <button class="tab-btn" onclick="APP.tab('battery', this)" style="color:var(--orange);">Battery</button>
            <button class="tab-btn" onclick="APP.tab('ai', this)" style="color:var(--purple);">AI Analysis</button>
            <button class="tab-btn" onclick="APP.tab('scenarios', this)" style="color:var(--success);">Scenarios</button>
        </div>

        <!-- VISUALIZER -->
        <div id="view-map" class="view-pane active">
            <svg id="svgRender" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
                <defs>
                    <marker id="arrowhead" markerWidth="6" markerHeight="4" refX="0" refY="2" orient="auto">
                        <polygon points="0 0, 6 2, 0 4" fill="white"/>
                    </marker>
                </defs>
                <g id="gPanels"></g>
                <g id="gStrings"></g>
                <g id="gLabels"></g>
                <g id="gPoints"></g>
            </svg>
            <div class="hud-panel">
                <div class="lbl" style="margin-bottom:8px; border-bottom:1px solid #334155; padding-bottom:5px;">Shadow Simulation</div>
                <div class="slide-lbl"><span>Day</span> <span id="lblDay">Jan 1</span></div>
                <input type="range" id="rngDay" min="0" max="364" value="172" oninput="APP.sim()">
                <div class="slide-lbl"><span>Time</span> <span id="lblTime">12:00</span></div>
                <input type="range" id="rngTime" min="0" max="47" value="24" oninput="APP.sim()">
                <div class="slide-lbl"><span>Rotation</span> <span id="lblRot">0&deg;</span></div>
                <input type="range" id="rngRot" min="0" max="360" value="0" oninput="APP.render()">
            </div>
        </div>

        <!-- STRINGING VIEW -->
        <div id="view-string" class="view-pane">
            <svg id="svgString" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
                <g id="gStringPanels"></g>
                <g id="gStringLines"></g>
                <g id="gStringLabels"></g>
            </svg>
            <div class="string-mode-hud" id="stringHud">
                <div class="lbl" style="color:var(--purple);">String Builder</div>
                <div style="font-size:10px; color:#94a3b8; margin-bottom:10px;">Click panels to add/remove from current string</div>
                <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:6px;">
                    <button class="btn-sm btn-purple" onclick="APP.newString()">+ New String</button>
                    <button class="btn-sm btn-success" onclick="APP.finishString()">Finish String</button>
                    <button class="btn-sm btn-danger" onclick="APP.undoLastPanel()">Undo Panel</button>
                </div>
                <div id="currentStringInfo" style="margin-top:6px; font-size:11px; padding:8px; background:rgba(0,0,0,0.3); border-radius:4px;">
                    No string active
                </div>
            </div>
        </div>

        <!-- PRODUCTION TABLE -->
        <div id="view-prod" class="view-pane" style="overflow:auto; padding:0;">
            <table class="prod-table">
                <thead>
                    <tr>
                        <th>Panel</th><th>String</th><th>Avg Irr</th><th>TSRF</th><th>Indep kWh</th><th>String kWh</th><th>Mismatch</th><th>EV SAV</th><th>Status</th>
                    </tr>
                </thead>
                <tbody id="tblProd"><tr><td colspan="9" style="text-align:center; padding:20px;">Run Analysis First</td></tr></tbody>
                <tfoot id="tblProdFoot" style="display:none;"></tfoot>
            </table>
        </div>

        <!-- 30-MIN TIMESERIES -->
        <div id="view-ts" class="view-pane" style="overflow:auto;">
            <div style="padding:15px;">
                <!-- Controls row -->
                <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:12px;">
                    <select id="tsModel" onchange="APP.renderTimeseries()" style="width:auto;">
                        <option value="independent">Model A: Independent</option>
                        <option value="string" selected>Model B: String-Level</option>
                    </select>
                    <select id="tsSelect" onchange="APP.renderTimeseries()" style="width:auto;">
                        <option value="system">System Total</option>
                    </select>
                    <div style="display:flex; gap:2px; margin-left:auto;">
                        <button class="btn-sm" id="tsPeriodDay" onclick="APP.tsPeriod='day'; APP.renderTimeseries()" style="background:var(--accent);">Day</button>
                        <button class="btn-sm btn-secondary" id="tsPeriodWeek" onclick="APP.tsPeriod='week'; APP.renderTimeseries()">Week</button>
                        <button class="btn-sm btn-secondary" id="tsPeriodMonth" onclick="APP.tsPeriod='month'; APP.renderTimeseries()">Month</button>
                        <button class="btn-sm btn-secondary" id="tsPeriodYear" onclick="APP.tsPeriod='year'; APP.renderTimeseries()">Year</button>
                    </div>
                </div>
                <!-- Date navigation -->
                <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                    <button class="btn-sm btn-secondary" onclick="APP.tsNav(-1)">◀</button>
                    <input type="range" id="tsDateSlider" min="0" max="364" value="172" oninput="APP.tsDay=parseInt(this.value); APP.renderTimeseries()" style="flex:1; margin:0;">
                    <button class="btn-sm btn-secondary" onclick="APP.tsNav(1)">▶</button>
                    <span id="tsDateLabel" style="font-size:11px; color:#94a3b8; min-width:120px; text-align:center;">Jun 21</span>
                </div>
                <!-- Main production chart -->
                <div id="tsChart" style="height:280px; padding:15px 15px 35px 50px; background:rgba(0,0,0,0.3); border-radius:6px; position:relative; margin-bottom:6px;">
                    <div style="color:#64748b; text-align:center; padding-top:110px;">Run analysis to generate timeseries</div>
                </div>
                <!-- Battery chart (split view — only shown when battery configured) -->
                <div id="tsBattChart" style="height:160px; padding:10px 15px 25px 50px; background:rgba(0,0,0,0.3); border-radius:6px; position:relative; margin-bottom:12px; display:none;">
                    <div style="color:#64748b; text-align:center; padding-top:50px; font-size:10px;">Battery chart appears after analysis with ESS configured</div>
                </div>
                <!-- Production model toggles -->
                <div style="display:flex; gap:6px; flex-wrap:wrap; margin-bottom:12px;">
                    <label style="font-size:10px; color:#94a3b8; cursor:pointer; display:flex; align-items:center; gap:3px;">
                        <input type="checkbox" id="tsShowA" checked onchange="APP.renderTimeseries()"> <span style="color:var(--accent);">■</span> Model A (Independent)
                    </label>
                    <label style="font-size:10px; color:#94a3b8; cursor:pointer; display:flex; align-items:center; gap:3px;">
                        <input type="checkbox" id="tsShowB" checked onchange="APP.renderTimeseries()"> <span style="color:var(--purple);">■</span> Model B (String)
                    </label>
                    <label style="font-size:10px; color:#94a3b8; cursor:pointer; display:flex; align-items:center; gap:3px;">
                        <input type="checkbox" id="tsShowC" checked onchange="APP.renderTimeseries()"> <span style="color:var(--success);">■</span> Model C (EagleView)
                    </label>
                    <span style="color:#334155; margin:0 4px;">|</span>
                    <label style="font-size:10px; color:#94a3b8; cursor:pointer; display:flex; align-items:center; gap:3px;">
                        <input type="checkbox" id="tsShowSoC" onchange="APP.renderTimeseries()"> <span style="color:var(--orange);">▓</span> Battery SoC
                    </label>
                    <label style="font-size:10px; color:#94a3b8; cursor:pointer; display:flex; align-items:center; gap:3px;">
                        <input type="checkbox" id="tsShowBattPower" onchange="APP.renderTimeseries()"> <span style="color:#22d3ee;">↕</span> Charge/Discharge
                    </label>
                </div>
                <!-- Stats dashboard -->
                <div id="tsStats"></div>
                <!-- String info -->
                <div id="tsStringInfo" style="margin-top:12px;"></div>
            </div>
        </div>

        <!-- INVERTER VIEW -->
        <div id="view-inverter" class="view-pane" style="overflow:auto; padding:15px;">
            <div id="inverterGrid">
                <div style="color:#64748b; text-align:center; padding-top:50px;">Configure inverters and strings to see analysis</div>
            </div>
        </div>
        <!-- Hidden state for inverter chart mode -->
        <input type="hidden" id="invChartMode" value="daily">

        <!-- BATTERY -->
        <div id="view-battery" class="view-pane" style="overflow:auto; padding:15px;">
            <div id="batteryContent">
                <div style="color:#64748b; text-align:center; padding-top:50px;">Configure ESS and run analysis to see battery simulation</div>
            </div>
        </div>

        <!-- AI ANALYSIS -->
        <div id="view-ai" class="view-pane" style="overflow:auto; padding:15px;">
            <div id="aiContent">
                <div style="color:#64748b; text-align:center; padding-top:50px;">Run analysis to generate AI recommendations</div>
            </div>
        </div>

        <div id="view-scenarios" class="view-pane" style="overflow:auto; padding:15px;">
            <div id="scenarioContent">
                <div style="color:#64748b; text-align:center; padding-top:50px;">Save scenarios to compare different design configurations</div>
            </div>
        </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="right-panel">
        <div class="card" id="resCard" style="display:none;">
            <span class="lbl">System Summary - Triple Model</span>
            <div class="stat-row-3">
                <div class="stat-item"><span class="stat-val-sm" id="valIndep">0</span><span class="stat-name">Independent kWh</span></div>
                <div class="stat-item"><span class="stat-val-sm" id="valString">0</span><span class="stat-name">String kWh</span></div>
                <div class="stat-item"><span class="stat-val-sm" id="valEV">0</span><span class="stat-name">EagleView kWh</span></div>
            </div>
            <div class="stat-row">
                <div class="stat-item"><span class="stat-val" id="valCount">0</span><span class="stat-name">Panels</span></div>
                <div class="stat-item"><span class="stat-val" id="valTSRF">0%</span><span class="stat-name">Avg TSRF</span></div>
            </div>
            <div class="stat-row">
                <div class="stat-item"><span class="stat-val" id="valDC">0 kW</span><span class="stat-name">DC Capacity</span></div>
                <div class="stat-item"><span class="stat-val" id="valMismatch">0%</span><span class="stat-name">Mismatch Loss</span></div>
            </div>
            <div class="stat-row" id="energyBalanceRow" style="display:none; margin-top:8px; padding-top:8px; border-top:1px solid #334155;">
                <div class="stat-item"><span class="stat-val-sm" id="valSelfConsume">0%</span><span class="stat-name">Self-Consumption</span></div>
                <div class="stat-item"><span class="stat-val-sm" id="valBattUtil">0%</span><span class="stat-name">Battery Util.</span></div>
            </div>
            <div class="stat-row" id="energyFlowRow" style="display:none;">
                <div class="stat-item"><span class="stat-val-sm" id="valGridExport">0</span><span class="stat-name">Grid Export kWh</span></div>
                <div class="stat-item"><span class="stat-val-sm" id="valBattStored">0</span><span class="stat-name">Battery kWh</span></div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <span class="lbl">Strings</span>
                <div style="display:flex; gap:4px;">
                    <button class="btn-sm btn-purple" onclick="APP.autoString()">Auto-String</button>
                    <button class="btn-sm btn-danger" onclick="APP.clearAllStrings()" title="Remove all strings">Clear</button>
                </div>
            </div>
            <div class="string-list" id="stringList">
                <div style="color:#64748b; font-size:11px; text-align:center; padding:10px;">No strings configured</div>
            </div>
        </div>

        <div class="card">
            <span class="lbl">String Electrical</span>
            <div id="stringElectrical" style="font-size:11px;">
                <div style="color:#64748b;">Select a string to view specs</div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <span class="lbl">Inverter Configuration</span>
                <button class="btn-sm btn-success" onclick="APP.addInverter()">+ Add Inverter</button>
            </div>
            <div id="invConfigList">
                <div style="color:#64748b; font-size:10px; text-align:center; padding:6px;">No inverters configured</div>
            </div>
            <div id="invUnassigned" style="display:none;"></div>
        </div>

        <div class="card" id="scenarioCard">
            <span class="lbl">Scenarios</span>
            <div style="display:flex; gap:4px; margin-bottom:6px;">
                <button class="btn-sm btn-success" onclick="APP.promptSaveScenario()">Save Current</button>
                <div style="position:relative; flex:1;">
                    <button class="btn-sm btn-secondary" style="width:100%;">Import JSON</button>
                    <input type="file" accept=".json" onchange="APP.importScenarioJSON(this.files[0]);this.value='';"
                        style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;">
                </div>
            </div>
            <div id="scenarioQuickList" style="max-height:120px; overflow-y:auto; font-size:10px;">
                <div style="color:#64748b; text-align:center; padding:6px;">No saved scenarios</div>
            </div>
            <button class="btn-sm btn-purple" onclick="APP.tab('scenarios',document.querySelector('[onclick*=scenarios]'))"
                style="margin-top:6px; width:100%;" id="btnCompare" disabled>Compare Scenarios</button>
        </div>

        <div class="card">
            <span class="lbl">Quick Actions</span>
            <button class="btn-sm btn-secondary" onclick="APP.exportConfig()" style="margin-bottom:5px;">Export Config JSON</button>
            <button class="btn-sm btn-success" onclick="APP.exportCSV()" style="margin-bottom:5px;">Export CSV</button>
            <button class="btn-sm btn-purple" onclick="APP.generateReport()">Generate PDF Report</button>
        </div>
    </div>
</div>

<div id="tooltip"></div>

<script>
// ============== EQUIPMENT PROFILES ==============
const EQUIPMENT = {
    panels: {
        "REC_Alpha_Pure_440": { name: "REC Alpha Pure 440W", watts: 440, voc: 48.4, vmp: 40.8, isc: 11.5, imp: 10.79, tempCoVoc: -0.0024, tempCoIsc: 0.0004, tempCoPmax: -0.0026, length: 1.82, width: 1.02, cells: 132, bypassDiodes: 3, cellsPerSubstring: 44 },
        "REC_Alpha_Pure_RX_460": { name: "REC Alpha Pure RX 460W", watts: 460, voc: 50.1, vmp: 42.2, isc: 11.6, imp: 10.9, tempCoVoc: -0.0024, tempCoIsc: 0.0004, tempCoPmax: -0.0026, length: 1.86, width: 1.02, cells: 132, bypassDiodes: 3, cellsPerSubstring: 44 },
        "SEG_430_BTD_BG": { name: "SEG 430 BTD BG Bifacial", watts: 430, voc: 45.2, vmp: 37.8, isc: 11.85, imp: 11.38, tempCoVoc: -0.0026, tempCoIsc: 0.0005, tempCoPmax: -0.0034, length: 1.72, width: 1.13, cells: 108, bypassDiodes: 3, cellsPerSubstring: 36 },
        "Hyundai_HIN_T440NF": { name: "Hyundai HIN-T440NF(BK)", watts: 440, voc: 46.1, vmp: 38.5, isc: 11.78, imp: 11.43, tempCoVoc: -0.0026, tempCoIsc: 0.0005, tempCoPmax: -0.0029, length: 1.72, width: 1.13, cells: 120, bypassDiodes: 3, cellsPerSubstring: 40 },
        "QCells_QPeak_420": { name: "Q.CELLS Q.PEAK DUO 420W", watts: 420, voc: 44.8, vmp: 37.5, isc: 11.95, imp: 11.2, tempCoVoc: -0.0027, tempCoIsc: 0.0005, tempCoPmax: -0.0034, length: 1.76, width: 1.05, cells: 120, bypassDiodes: 3, cellsPerSubstring: 40 },
        "Canadian_HiHero_445": { name: "Canadian HiHero 445W", watts: 445, voc: 49.2, vmp: 41.3, isc: 11.42, imp: 10.78, tempCoVoc: -0.0025, tempCoIsc: 0.0004, tempCoPmax: -0.0029, length: 1.85, width: 1.03, cells: 132, bypassDiodes: 3, cellsPerSubstring: 44 },
        "Trina_Vertex_S_435": { name: "Trina Vertex S+ 435W", watts: 435, voc: 47.6, vmp: 40.1, isc: 11.52, imp: 10.85, tempCoVoc: -0.0024, tempCoIsc: 0.0005, tempCoPmax: -0.0030, length: 1.78, width: 1.06, cells: 144, bypassDiodes: 3, cellsPerSubstring: 48 },
        "Jinko_Tiger_Neo_445": { name: "Jinko Tiger Neo 445W", watts: 445, voc: 48.9, vmp: 41.0, isc: 11.48, imp: 10.85, tempCoVoc: -0.0025, tempCoIsc: 0.0004, tempCoPmax: -0.0029, length: 1.84, width: 1.03, cells: 144, bypassDiodes: 3, cellsPerSubstring: 48 }
    },
    inverters: {
        "Tesla_PW3_Inverter": { name: "Tesla Powerwall 3 (11.5kW)", acPower: 11500, dcMax: 15000, mpptMin: 60, mpptMax: 500, channels: 6, maxIsc: 25, efficiency: 0.975, isIntegrated: true },
        "Tesla_Inverter_3_8": { name: "Tesla Inverter 3.8kW", acPower: 3800, dcMax: 7600, mpptMin: 80, mpptMax: 500, channels: 2, maxIsc: 18, efficiency: 0.97 },
        "Tesla_Inverter_5_0": { name: "Tesla Inverter 5.0kW", acPower: 5000, dcMax: 10000, mpptMin: 90, mpptMax: 500, channels: 2, maxIsc: 18, efficiency: 0.971 },
        "Tesla_Inverter_7_6": { name: "Tesla Inverter 7.6kW", acPower: 7600, dcMax: 11400, mpptMin: 100, mpptMax: 500, channels: 4, maxIsc: 20, efficiency: 0.975 },
        "Enphase_IQ8A": { name: "Enphase IQ8A Micro", acPower: 366, dcMax: 440, mpptMin: 27, mpptMax: 54, channels: 1, maxIsc: 12, efficiency: 0.97, isMicro: true },
        "Enphase_IQ8M": { name: "Enphase IQ8M Micro", acPower: 330, dcMax: 400, mpptMin: 24, mpptMax: 54, channels: 1, maxIsc: 12, efficiency: 0.968, isMicro: true },
        "Enphase_IQ8P": { name: "Enphase IQ8P Micro", acPower: 400, dcMax: 480, mpptMin: 30, mpptMax: 58, channels: 1, maxIsc: 12, efficiency: 0.972, isMicro: true },
        "SolarEdge_SE7600H": { name: "SolarEdge SE7600H", acPower: 7600, dcMax: 11400, mpptMin: 150, mpptMax: 500, channels: 1, maxIsc: 22, efficiency: 0.992 },
        "Generac_PWRcell": { name: "Generac PWRcell 7.6kW", acPower: 7600, dcMax: 11000, mpptMin: 120, mpptMax: 500, channels: 3, maxIsc: 18, efficiency: 0.97 }
    },
    ess: {
        "None": { name: "No ESS", capacity: 0, power: 0, roundTrip: 0, dcChargeRate: 0, dcChargeRateExpanded: 0, type: 'none', expansionCapacity: 0, expansionPower: 0, maxExpansions: 0 },
        "Tesla_PW2": { name: "Tesla Powerwall 2", capacity: 13.5, power: 5, roundTrip: 0.90, dcChargeRate: 0, dcChargeRateExpanded: 0, type: 'ac_coupled', expansionCapacity: 0, expansionPower: 0, maxExpansions: 0 },
        "Tesla_PW3": { name: "Tesla Powerwall 3", capacity: 13.5, power: 11.5, roundTrip: 0.92, dcChargeRate: 5000, dcChargeRateExpanded: 8000, type: 'dc_coupled', expansionCapacity: 13.5, expansionPower: 3300, maxExpansions: 3 },
        "Enphase_IQ_5P": { name: "Enphase IQ Battery 5P", capacity: 5, power: 3.84, roundTrip: 0.89, dcChargeRate: 0, dcChargeRateExpanded: 0, type: 'ac_coupled', expansionCapacity: 0, expansionPower: 0, maxExpansions: 0 },
        "Enphase_IQ_10T": { name: "Enphase IQ Battery 10T", capacity: 10.5, power: 5.76, roundTrip: 0.90, dcChargeRate: 0, dcChargeRateExpanded: 0, type: 'ac_coupled', expansionCapacity: 0, expansionPower: 0, maxExpansions: 0 },
        "Generac_PWRcell_M4": { name: "Generac PWRcell M4", capacity: 9, power: 4.5, roundTrip: 0.87, dcChargeRate: 0, dcChargeRateExpanded: 0, type: 'ac_coupled', expansionCapacity: 0, expansionPower: 0, maxExpansions: 0 }
    }
};

const STRING_COLORS = ['#38bdf8', '#34d399', '#fb923c', '#a78bfa', '#f472b6', '#facc15', '#22d3ee', '#84cc16'];

// ============== APP STATE ==============
const APP = {
    geo: [],
    rad: [],
    shadeData: {},
    rot: 0,
    validRadPoints: [],
    hasShade: false,
    panelStats: [],

    // Equipment state
    panel: null,
    inverter: null,
    ess: null,

    // Stringing state
    strings: [],
    currentString: [],
    activeStringIdx: -1,
    panelToString: {},

    // Multi-inverter state
    inverters: [],       // [{id, typeKey, strings: [stringIdx], name}]
    stringToInverter: {}, // stringIdx -> inverterIdx

    // Triple production model
    panelTimeseries: [],   // Model A: per-panel independent power arrays (17520 each)
    stringTimeseries: [],  // Model B: per-string mismatch-adjusted power arrays (17520 each)
    inverterTimeseries: [],// per-inverter: [{dcInput, acOutput, clippedW}] x 17520
    eagleViewProduction: { monthly: [], annual: 0, panelSAV: [], panelTSRF: [] },

    // Clipping
    clippingThreshold: 1.0,
    clippingEvents: [],
    batteryChargingEvents: [],
    clippingLoss: 0,
    exportLimitW: 0,
    exportCurtailed: 0,

    // Home consumption
    homeConsumption: {
        enabled: false,
        annualKwh: 0,
        monthlyKwh: null,
        profile: null,
        inputMethod: 'annual',
        priorityMode: 'self',
        zipCode: '',
        sqFt: 0,
        climateZone: 'mixed', // hot, mixed, cold — derived from zip code
        backupReservePct: 20  // 0-80%, Tesla default 20%. Battery won't discharge below this for self-consumption.
    },

    // Utility rates for economic analysis
    utilityRates: { standard: 0.14, peak: 0.35, offPeak: 0.10 },

    // Battery analytics (computed after dispatch)
    batteryAnalytics: null,

    // Battery state (per-inverter for DC-coupled, system-level for AC-coupled)
    batteryState: [],       // per-inverter: {socWh: Float32Array(17520), chargeW: Float32Array(17520), dischargeW: Float32Array(17520)}
    batteryConfig: [],      // per-inverter: {essKey, expansions, totalCapacityWh, totalDcChargeW, maxDischargeW, roundTrip}
    systemBatteryState: null, // for AC-coupled: same structure as batteryState entry
    systemBatteryConfig: null, // {essKey, count, totalCapacityWh, chargeRateW, dischargeRateW, roundTrip}

    // Energy balance summary
    energyBalance: {
        totalProduction: 0,
        selfConsumed: 0,
        gridExport: 0,
        gridImport: 0,
        batteryCharged: 0,
        batteryDischarged: 0,
        batteryLosses: 0,
        curtailed: 0,
        clipped: 0
    },

    // Dispatch timeseries (system-level per-timestep)
    dispatchTimeseries: [],

    // Battery chart navigation
    batteryChartMode: 'daily',
    batterySelectedDay: -1,

    // Chart navigation state
    tsPeriod: 'day',       // 'day', 'week', 'month', 'year'
    tsDay: 172,            // day of year (0-364) for day/week views
    invChartMode: 'daily', // 'daily', 'weekly', 'monthly' for inverter charts
    invSelectedDay: -1,    // selected day in inverter chart (-1 = none)

    // Scenario Manager
    scenarios: [],
    activeScenarioIdx: -1,
    compareSelection: [],

    // ============== LOGGING ==============
    log: (m, t) => {
        const l = document.getElementById('log');
        const ts = new Date().toLocaleTimeString().split(' ')[0];
        l.innerHTML += `<div class="ln-${t||''}">[${ts}] ${m}</div>`;
        l.scrollTop = l.scrollHeight;
    },

    // ============== INITIALIZATION ==============
    init: () => {
        const selPanel = document.getElementById('selPanel');
        const selInverter = document.getElementById('selInverter');
        const selESS = document.getElementById('selESS');

        Object.entries(EQUIPMENT.panels).forEach(([k, v]) => {
            selPanel.innerHTML += `<option value="${k}">${v.name}</option>`;
        });
        Object.entries(EQUIPMENT.inverters).forEach(([k, v]) => {
            selInverter.innerHTML += `<option value="${k}">${v.name}</option>`;
        });
        Object.entries(EQUIPMENT.ess).forEach(([k, v]) => {
            selESS.innerHTML += `<option value="${k}">${v.name}</option>`;
        });

        APP.updateEquipment();
    },

    updateEquipment: () => {
        APP.panel = EQUIPMENT.panels[document.getElementById('selPanel').value];
        APP.inverter = EQUIPMENT.inverters[document.getElementById('selInverter').value];
        APP.ess = EQUIPMENT.ess[document.getElementById('selESS').value];

        const summary = document.getElementById('equipSummary');
        const inv = APP.inverter;
        const pan = APP.panel;

        const tempMin = parseFloat(document.getElementById('tempMin').value) || -20;
        const tempMax = parseFloat(document.getElementById('tempMax').value) || 45;

        const vocCold = pan.voc * (1 + pan.tempCoVoc * (tempMin - 25));
        const vmpHot = pan.vmp * (1 + pan.tempCoVoc * (tempMax - 25));

        const maxModules = Math.floor(inv.mpptMax / vocCold);
        const minModules = Math.ceil(inv.mpptMin / vmpHot);

        summary.innerHTML = `
            <div style="margin-bottom:4px;"><strong>${pan.name}</strong></div>
            <div>Voc: ${pan.voc}V | Vmp: ${pan.vmp}V | Imp: ${pan.imp}A</div>
            <div>Cells: ${pan.cells} | Bypass Diodes: ${pan.bypassDiodes} | Substrings: ${pan.bypassDiodes}</div>
            <div style="margin-top:6px; padding-top:6px; border-top:1px solid #334155;">
                <strong>String Sizing (${tempMin}&deg;C to ${tempMax}&deg;C)</strong><br>
                Min: ${minModules} panels | Max: ${maxModules} panels
            </div>
        `;

        APP.recalcStrings();
    },

    updateClipThreshold: () => {
        const val = parseInt(document.getElementById('rngClipThresh').value);
        APP.clippingThreshold = val / 100;
        document.getElementById('lblClipThresh').innerText = val + '%';
        if(APP.stringTimeseries.length > 0) {
            APP.runEnergyDispatch();
            APP.renderInverterView();
        }
    },

    updateExportLimit: () => {
        const kw = parseFloat(document.getElementById('acExportLimit').value) || 0;
        APP.exportLimitW = kw * 1000;
        APP.log(`AC export limit: ${kw > 0 ? kw + ' kW' : 'unlimited'}`);
        if(APP.stringTimeseries.length > 0) {
            APP.runEnergyDispatch();
            APP.renderInverterView();
        }
    },

    // ============== HOME CONSUMPTION ==============
    setConsumptionMethod: (method) => {
        APP.homeConsumption.inputMethod = method;
        document.getElementById('consumeAnnualInput').style.display = method === 'annual' ? 'block' : 'none';
        document.getElementById('consumeMonthlyInput').style.display = method === 'monthly' ? 'block' : 'none';
    },

    loadConsumptionCSV: (el) => {
        const f = el.files[0];
        if(!f) return;
        const r = new FileReader();
        r.onload = e => {
            const txt = e.target.result;
            // Parse CSV: expect 12 values (monthly kWh), one per line or comma-separated
            const values = txt.replace(/\r\n/g, '\n').split(/[,\n]/).map(v => parseFloat(v.trim())).filter(v => !isNaN(v) && v >= 0);
            if(values.length >= 12) {
                APP.homeConsumption.monthlyKwh = values.slice(0, 12);
                APP.homeConsumption.annualKwh = values.slice(0, 12).reduce((a, b) => a + b, 0);
                APP.homeConsumption.enabled = true;
                APP.generateConsumptionProfile();
                document.getElementById('boxConsumption').classList.add('done');
                document.getElementById('txtConsumption').innerText = f.name;
                APP.log(`Loaded monthly consumption: ${Math.round(APP.homeConsumption.annualKwh).toLocaleString()} kWh/yr`, 'ok');
            } else {
                APP.log(`CSV must contain 12 monthly kWh values, found ${values.length}`, 'err');
            }
        };
        r.readAsText(f);
    },

    updateConsumption: () => {
        const kwh = parseFloat(document.getElementById('annualConsumption').value) || 0;
        const zip = (document.getElementById('consumeZipCode').value || '').trim();
        const sqFt = parseFloat(document.getElementById('consumeSqFt').value) || 0;
        APP.homeConsumption.annualKwh = kwh;
        APP.homeConsumption.enabled = kwh > 0;
        APP.homeConsumption.monthlyKwh = null;
        APP.homeConsumption.zipCode = zip;
        APP.homeConsumption.sqFt = sqFt;
        APP.homeConsumption.climateZone = APP.getClimateZone(zip);
        if(kwh > 0) {
            APP.generateConsumptionProfile();
            APP.log(`Home consumption: ${Math.round(kwh).toLocaleString()} kWh/yr (${APP.homeConsumption.climateZone} climate, ${sqFt || 'unknown'} sqft)`, 'ok');
        } else {
            APP.homeConsumption.profile = null;
            APP.log('Home consumption disabled.');
        }
        if(APP.stringTimeseries.length > 0) {
            APP.runEnergyDispatch();
            APP.renderInverterView();
            APP.renderBatteryView();
        }
    },

    // Zip code → climate zone mapping (first 3 digits of zip to region)
    // Based on IECC climate zones: hot (1-3), mixed (4), cold (5-7)
    getClimateZone: (zip) => {
        if(!zip || zip.length < 3) return 'mixed';
        const prefix = parseInt(zip.substring(0, 3));
        // Hot climates: FL, TX south, AZ, NM, SoCal, HI, southern GA/AL/MS/LA/SC
        const hotPrefixes = [
            // FL (320-349)
            [320,349],
            // South TX (780-789, 797-799)
            [780,789],[797,799],
            // AZ (850-865)
            [850,865],
            // SoCal (900-935)
            [900,935],
            // HI (967-968)
            [967,968],
            // South GA (300-319)
            [300,319],
            // South AL (350-369)
            [350,369],
            // MS (386-397)
            [386,397],
            // LA (700-714)
            [700,714],
            // SC coast (290-299)
            [290,299],
            // NV south (889-891)
            [889,891]
        ];
        const coldPrefixes = [
            // NY upstate (120-149)
            [120,149],
            // New England (010-069)
            [10,69],
            // MN (550-567)
            [550,567],
            // WI (530-549)
            [530,549],
            // MI (480-499)
            [480,499],
            // ND (580-588)
            [580,588],
            // SD (570-577)
            [570,577],
            // MT (590-599)
            [590,599],
            // WY (820-831)
            [820,831],
            // ID (832-838)
            [832,838],
            // AK (995-999)
            [995,999],
            // CO mountains (800-816)
            [800,816],
            // IA (500-528)
            [500,528],
            // NE (680-693)
            [680,693],
            // NH/VT/ME already in New England range
            // PA north (150-168)
            [150,168],
            // OR/WA north (970-986)
            [970,986]
        ];
        for(const [lo, hi] of hotPrefixes) { if(prefix >= lo && prefix <= hi) return 'hot'; }
        for(const [lo, hi] of coldPrefixes) { if(prefix >= lo && prefix <= hi) return 'cold'; }
        return 'mixed';
    },

    generateConsumptionProfile: () => {
        const annual = APP.homeConsumption.annualKwh;
        if(annual <= 0) { APP.homeConsumption.profile = null; return; }

        const profile = new Float32Array(17520);
        const monthly = APP.homeConsumption.monthlyKwh;
        const zone = APP.homeConsumption.climateZone || 'mixed';

        // ── Monthly distribution (fraction of annual per month) ──
        let monthFractions;
        if(monthly) {
            const total = monthly.reduce((a, b) => a + b, 0);
            monthFractions = monthly.map(v => v / total);
        } else {
            // Climate-aware monthly distribution based on EIA regional data
            // Format: [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]
            const monthlyShapes = {
                hot:   [0.070, 0.065, 0.065, 0.072, 0.090, 0.110, 0.125, 0.125, 0.105, 0.080, 0.048, 0.045],
                mixed: [0.098, 0.090, 0.080, 0.072, 0.078, 0.092, 0.100, 0.098, 0.085, 0.073, 0.082, 0.052],
                cold:  [0.108, 0.100, 0.090, 0.076, 0.070, 0.078, 0.088, 0.085, 0.075, 0.072, 0.085, 0.073]
            };
            // Normalize to ensure they sum to exactly 1
            const raw = monthlyShapes[zone] || monthlyShapes.mixed;
            const rawSum = raw.reduce((a, b) => a + b, 0);
            monthFractions = raw.map(v => v / rawSum);
        }

        // ── Realistic 24-hour load shape (48 half-hour slots) ──
        // Based on NREL residential load profiles and EIA hourly demand studies
        // Smooth continuous curve — NO dead zones. Every hour has meaningful load.
        //
        // The shape represents a typical residential day:
        //   Midnight-5am:  Baseload (fridge, HVAC standby, phantom loads, water heater cycling)
        //   5am-7am:       Wake-up ramp (lights, coffee, water heater recovery, morning routine)
        //   7am-9am:       Morning activity (cooking, showers, laundry start)
        //   9am-12pm:      Mid-morning (some occupancy load, HVAC maintaining)
        //   12pm-2pm:      Midday bump (lunch, TV, HVAC load from afternoon heat)
        //   2pm-4pm:       Afternoon (HVAC peak in summer, moderate base in winter)
        //   4pm-5pm:       Pre-evening ramp (people arriving home, appliances starting)
        //   5pm-8pm:       Evening peak (cooking, lighting, TV, EV charging, laundry/dishes)
        //   8pm-10pm:      Evening wind-down (TV, lights, dishwasher, reduced HVAC)
        //   10pm-midnight: Late night (lights off gradually, HVAC settling, phantom loads)

        // Base hourly shape (interpolation points at each hour, 0-24)
        // Values are relative weights (will be normalized)
        const baseHourlyShape = {
            hot: [
                0.55, 0.50, 0.48, 0.47, 0.47, 0.50, // 0-5: overnight baseload (higher in hot = AC)
                0.60, 0.72, 0.78, 0.75, 0.73, 0.76, // 6-11: morning + HVAC ramp
                0.80, 0.85, 0.92, 0.95, 0.98, 1.00, // 12-17: afternoon AC peak + pre-evening
                1.10, 1.15, 1.08, 0.95, 0.80, 0.68, // 18-23: evening peak then settle
                0.55  // wrap to midnight
            ],
            mixed: [
                0.45, 0.42, 0.40, 0.38, 0.38, 0.42, // 0-5: overnight baseload
                0.55, 0.70, 0.75, 0.65, 0.58, 0.55, // 6-11: morning routine
                0.58, 0.60, 0.62, 0.65, 0.75, 0.90, // 12-17: midday moderate + pre-evening
                1.10, 1.15, 1.10, 0.95, 0.78, 0.60, // 18-23: evening peak
                0.45  // wrap to midnight
            ],
            cold: [
                0.52, 0.48, 0.46, 0.45, 0.46, 0.50, // 0-5: overnight (heating baseload)
                0.65, 0.82, 0.85, 0.72, 0.62, 0.58, // 6-11: morning wake-up + heating demand
                0.58, 0.56, 0.55, 0.58, 0.68, 0.85, // 12-17: daytime dip + pre-evening ramp
                1.05, 1.15, 1.10, 0.95, 0.80, 0.65, // 18-23: evening peak
                0.52  // wrap to midnight
            ]
        };

        const hourlyPts = baseHourlyShape[zone] || baseHourlyShape.mixed;

        // Seasonal time-of-day adjustment: summer shifts HVAC load to afternoon, winter to morning/evening
        // Month-specific multiplier per hour range
        const getSeasonalTodAdj = (month, hour) => {
            // Summer months (Jun-Sep): boost afternoon/evening HVAC
            if(month >= 5 && month <= 8) {
                if(hour >= 12 && hour <= 18) return zone === 'hot' ? 1.25 : 1.10;
                if(hour >= 0 && hour <= 5) return zone === 'hot' ? 1.15 : 1.0; // overnight AC
            }
            // Winter months (Nov-Feb): boost morning heating
            if(month >= 10 || month <= 1) {
                if(hour >= 5 && hour <= 9) return zone === 'cold' ? 1.20 : 1.05;
                if(hour >= 17 && hour <= 21) return zone === 'cold' ? 1.15 : 1.05;
            }
            return 1.0;
        };

        // Weekend vs weekday shape adjustment (slight, applied as a blend)
        // Weekends: later wake-up, more midday usage, slightly higher overall
        const getWeekendAdj = (hour) => {
            if(hour >= 6 && hour < 9) return 0.85; // later wake-up
            if(hour >= 9 && hour < 16) return 1.15; // more midday activity (people home)
            if(hour >= 16 && hour < 21) return 1.05; // still has evening peak but less pronounced
            return 1.0;
        };

        // Generate profile: distribute annual kWh across all 17520 steps
        const annualWh = annual * 1000;
        for(let d = 0; d < 365; d++) {
            const dt = new Date(2024, 0, d + 1);
            const m = dt.getMonth();
            const dow = dt.getDay(); // 0=Sun, 6=Sat
            const isWeekend = (dow === 0 || dow === 6);
            const daysInMonth = new Date(2024, m + 1, 0).getDate();
            const dailyWh = annualWh * monthFractions[m] / daysInMonth;

            // Build this day's 48-slot weight array by cubic interpolation of hourly points
            const dayWeights = new Float32Array(48);
            let dayWeightSum = 0;
            for(let h = 0; h < 48; h++) {
                const hour = h / 2;
                // Linear interpolation between hourly points
                const h0 = Math.floor(hour);
                const h1 = Math.min(24, h0 + 1);
                const frac = hour - h0;
                let w = hourlyPts[h0] * (1 - frac) + hourlyPts[h1] * frac;

                // Apply seasonal TOD adjustment
                w *= getSeasonalTodAdj(m, hour);

                // Apply weekend adjustment (blend: 70% weekday shape + 30% weekend-adjusted)
                if(isWeekend) {
                    w *= (0.3 + 0.7 * getWeekendAdj(hour));
                }

                // Small random-like variation using deterministic noise (±5%)
                const noise = 1.0 + 0.05 * Math.sin(d * 7.3 + h * 2.1);
                w *= noise;

                dayWeights[h] = Math.max(0.1, w);
                dayWeightSum += dayWeights[h];
            }

            // Scale weights so this day's total matches dailyWh
            for(let h = 0; h < 48; h++) {
                const stepWh = dailyWh * (dayWeights[h] / dayWeightSum);
                profile[d * 48 + h] = stepWh / 0.5; // Wh per 30min → Watts
            }
        }

        APP.homeConsumption.profile = profile;

        // Verify total (should match annual within rounding)
        const totalGenerated = Array.from(profile).reduce((s, w) => s + w * 0.5, 0) / 1000; // kWh

        // Update summary display
        const summary = document.getElementById('consumptionSummary');
        const avgW = annualWh / 8760;
        const peakW = Math.max(...profile);
        summary.style.display = 'block';
        summary.innerHTML = `
            <div>Annual: <strong>${Math.round(annual).toLocaleString()} kWh</strong> (gen: ${Math.round(totalGenerated).toLocaleString()})</div>
            <div>Climate: <strong>${zone.charAt(0).toUpperCase() + zone.slice(1)}</strong>${APP.homeConsumption.sqFt ? ' | ' + APP.homeConsumption.sqFt.toLocaleString() + ' sqft' : ''}</div>
            <div>Avg Load: <strong>${(avgW / 1000).toFixed(2)} kW</strong> | Peak: <strong>${(peakW / 1000).toFixed(2)} kW</strong></div>
            <div>Daily Avg: <strong>${(annual / 365).toFixed(1)} kWh/day</strong></div>
        `;
    },

    updatePriorityMode: () => {
        APP.homeConsumption.priorityMode = document.getElementById('selPriorityMode').value;
        APP.log(`Priority mode: ${APP.homeConsumption.priorityMode}`);
        if(APP.stringTimeseries.length > 0) {
            APP.runEnergyDispatch();
            APP.renderInverterView();
            APP.renderBatteryView();
        }
    },

    // ============== FILE LOADING ==============
    loadGeo: (el) => {
        const f = el.files[0];
        if(!f) return;
        const hadPreviousGeo = APP.geo.length > 0;
        const hadRad = APP.rad.length > 0;
        APP.log(`Loading: ${f.name}${hadPreviousGeo ? ' (hot-swap)' : ''}`);
        const r = new FileReader();
        r.onload = e => {
            // Preserve rad & shade data for hot-swap
            const savedRad = APP.rad;
            const savedShade = APP.shadeData;
            const savedHasShade = APP.hasShade;

            APP.parseJSON(e.target.result);

            // Restore DXF & shade if hot-swapping
            if(hadPreviousGeo && hadRad) {
                APP.rad = savedRad;
                APP.shadeData = savedShade;
                APP.hasShade = savedHasShade;
                APP.log("Hot-swap: Preserved DXF radiance & shade data", 'ok');
            }

            // Reset stringing & inverter assignments (panel indices may change)
            APP.strings = [];
            APP.currentString = [];
            APP.activeStringIdx = -1;
            APP.panelToString = {};
            APP.inverters.forEach(inv => { inv.strings = []; });
            APP.stringToInverter = {};
            APP.panelTimeseries = [];
            APP.stringTimeseries = [];
            APP.inverterTimeseries = [];
            APP.clippingEvents = [];
            APP.batteryChargingEvents = [];
            APP.renderStringList();
            APP.renderInverterConfig();

            document.getElementById('boxGeo').classList.add('done');
            document.getElementById('txtGeo').innerText = f.name;
            APP.checkReady();

            if(hadPreviousGeo && hadRad) {
                APP.log("Hot-swap complete. Re-run analysis with new layout.", 'ok');
            }
        };
        r.readAsText(f);
    },

    loadRad: (el) => {
        const f = el.files[0];
        if(!f) return;
        APP.log(`Loading: ${f.name}`);
        const r = new FileReader();
        r.onload = e => {
            APP.parseDXF(e.target.result);
            document.getElementById('boxRad').classList.add('done');
            document.getElementById('txtRad').innerText = f.name;
            APP.checkReady();
        };
        r.readAsText(f);
    },

    handleData: async (el) => {
        const files = Array.from(el.files);
        if(!files.length) return;

        APP.shadeData = {};
        APP.hasShade = false;

        const zipFile = files.find(f => f.name.endsWith('.zip'));
        const csvFiles = files.filter(f => f.name.endsWith('.csv'));

        if(zipFile) {
            APP.log("Extracting shading data from ZIP...");
            try {
                const zip = new JSZip();
                const contents = await zip.loadAsync(zipFile);
                const csvs = Object.values(contents.files).filter(f => f.name.match(/shading_.*\.csv$/i));
                for(const f of csvs) {
                    const match = f.name.match(/_(IP\d+|C\d+)\.csv$/);
                    if(match) {
                        const txt = await f.async("string");
                        APP.shadeData[match[1]] = txt.replace(/[\r\n\s]+/g, '');
                    }
                }
            } catch(e) { APP.log("ZIP Error: "+e.message, 'err'); }
        }

        // Also handle individually selected CSV files
        if(csvFiles.length > 0) {
            APP.log(`Loading ${csvFiles.length} shade CSV file(s)...`);
            for(const csvFile of csvFiles) {
                const match = csvFile.name.match(/_(IP\d+|C\d+)\.csv$/);
                if(match) {
                    const txt = await new Promise((resolve, reject) => {
                        const r = new FileReader();
                        r.onload = e => resolve(e.target.result);
                        r.onerror = e => reject(e);
                        r.readAsText(csvFile);
                    });
                    APP.shadeData[match[1]] = txt.replace(/[\r\n\s]+/g, '');
                }
            }
        }

        const loadedCount = Object.keys(APP.shadeData).length;
        if(loadedCount > 0) {
            APP.hasShade = true;
            APP.log(`Loaded ${loadedCount} shade profiles.`, 'ok');

            // If analysis was already run, re-run with shade data applied
            if(APP.panelStats.length > 0) {
                APP.log("Re-running analysis with shade data...", 'ok');
                APP.process();
            }
        } else {
            APP.log("No valid shade profiles found in the selected files.", 'warn');
        }

        document.getElementById('boxZip').classList.add('done');
    },

    checkReady: () => {
        if(APP.geo.length && APP.rad.length) {
            document.getElementById('btnRun').disabled = false;
            APP.log("Ready to analyze.", 'ok');
        }
    },

    parseJSON: (txt) => {
        try {
            const d = JSON.parse(txt);
            APP.geo = [];
            const visited = new Set();
            const scan = o => {
                if(!o || typeof o !== 'object') return;
                if(o.data && Array.isArray(o.data) && o.data.length > 2 && o.data[0].x !== undefined) {
                    const key = `${o.data[0].x},${o.data[0].y}`;
                    if(!visited.has(key)) {
                        visited.add(key);
                        if(o.type !== 'obstruction' && o.type !== 'tree') {
                            APP.geo.push(o.data.map(p => ({x:p.x, y: -p.y})));
                        }
                    }
                }
                if(Array.isArray(o)) o.forEach(scan); else Object.values(o).forEach(scan);
            };
            scan(d);

            // Parse EagleView production data (Model C)
            APP.eagleViewProduction = { monthly: [], annual: 0, panelSAV: [], panelTSRF: [] };
            if(d.monthlyProduction && Array.isArray(d.monthlyProduction)) {
                APP.eagleViewProduction.monthly = d.monthlyProduction;
                APP.eagleViewProduction.annual = d.monthlyProduction.reduce((a,b) => a+b, 0);
                APP.log(`EagleView annual estimate: ${Math.round(APP.eagleViewProduction.annual).toLocaleString()} kWh`, 'ok');
            }
            if(d.panels && Array.isArray(d.panels)) {
                d.panels.forEach(p => {
                    APP.eagleViewProduction.panelSAV.push(p.SAV || 0);
                    APP.eagleViewProduction.panelTSRF.push(p.TSRF || 0);
                });
            }

            APP.log(`Found ${APP.geo.length} panels.`, 'ok');
        } catch(e) { APP.log("JSON Parse Error: "+e.message, 'err'); }
    },

    parseDXF: (txt) => {
        APP.rad = [];
        const lines = txt.split(/\r\n|\n/);
        let inPt=false, pt={x:0,y:0,id:null,meta:{}}, inX=false, lastK="";
        for(let i=0; i<lines.length; i++) {
            const c=lines[i].trim(), v=lines[i+1]?lines[i+1].trim():"";
            if(c==='0' && v==='POINT') {
                if(inPt && pt.id) APP.rad.push(pt);
                inPt=true; inX=false; pt={x:0,y:0,id:null,meta:{}};
            }
            if(inPt) {
                if(c==='10') pt.x=parseFloat(v);
                if(c==='20') pt.y= -parseFloat(v);
                if(c==='1001' && v==='EVT') inX=true;
                if(inX) {
                    if(c==='1000') {
                        if(v==='PointName') lastK='id';
                        else if(['ActualIrradiance','NominalIrradiance','TSRF'].includes(v)) lastK=v;
                        else if(lastK==='id') { pt.id=v; lastK=""; }
                    }
                    if(c==='1040' && lastK && lastK!=='id') { pt.meta[lastK] = parseFloat(v); lastK=""; }
                }
            }
        }
        if(inPt && pt.id) APP.rad.push(pt);
        // Filter out structural measurement points with zero irradiance/TSRF
        // These are roof-surface points that bleed into panel polygons at edges
        const beforeCount = APP.rad.length;
        APP.rad = APP.rad.filter(pt => (pt.meta.ActualIrradiance || 0) > 0 || (pt.meta.TSRF || 0) > 0);
        const filtered = beforeCount - APP.rad.length;
        APP.log(`Found ${APP.rad.length} radiance points.${filtered > 0 ? ` Filtered ${filtered} zero-irradiance roof points.` : ''}`, 'ok');
    },

    // ============== SHADE FACTOR HELPER ==============
    getPanelShadeFactorAtTimestep: (panel, timestepIdx) => {
        if(!APP.hasShade || panel.points.length === 0) return 1;
        let shaded = 0, total = 0;
        panel.points.forEach(ptId => {
            const seq = APP.shadeData[ptId];
            if(seq && timestepIdx < seq.length) {
                const c = seq[timestepIdx];
                if(c === '0' || c === '1') {
                    total++;
                    if(c === '0') shaded++;
                }
            }
        });
        if(total === 0) return 1;
        return 1 - (shaded / total);
    },

    // ============== SEASONAL TSRF DECOMPOSITION ==============
    // When shade data is missing (!APP.hasShade), the annual-average TSRF
    // suppresses summer peaks because it averages winter shade losses into
    // every timestep. This decomposes TSRF into a seasonal curve: higher in
    // summer (less obstruction shade at high sun angles), lower in winter.
    // Calibrated to preserve the production-weighted annual energy integral.
    getSeasonalTSRF: (panelTsrf, dayOfYear) => {
        if(APP.hasShade) return panelTsrf; // real shade profiles handle variation
        if(!panelTsrf || panelTsrf >= 1.0) return panelTsrf || 0.8;

        const SHADE_SWING = 0.65; // fraction of shade loss recovered in summer
        const B = SHADE_SWING * (1.0 - panelTsrf);
        const correctedBase = panelTsrf - 0.15 * B; // energy-preserving offset
        const S = Math.sin((dayOfYear - 80) / 365 * 2 * Math.PI);
        return Math.max(0.01, Math.min(1.0, correctedBase + B * S));
    },

    // ============== MAIN PROCESSING ==============
    process: () => {
        if(!APP.rad.length || !APP.panel) return;
        APP.log("Running production analysis...");

        let totalYield = 0, totalTSRF = 0, panelsWithData = 0;
        APP.panelStats = [];
        APP.validRadPoints = [];

        APP.geo.forEach((poly, idx) => {
            let rawPoints = [];
            APP.rad.forEach(pt => {
                if(APP.pointInPoly(pt, poly)) rawPoints.push(pt);
            });

            let finalPoints = [];
            if(rawPoints.length > 0) {
                // Pre-filter: exclude any zero-irradiance/zero-TSRF edge-bleed points
                rawPoints = rawPoints.filter(pt => (pt.meta.ActualIrradiance || 0) > 0);

                // IQR outlier filter on remaining valid points
                rawPoints.sort((a,b) => (a.meta.ActualIrradiance || 0) - (b.meta.ActualIrradiance || 0));
                const q1Vals = rawPoints[Math.floor(rawPoints.length * 0.25)];
                const q3Vals = rawPoints[Math.floor(rawPoints.length * 0.75)];
                const q1 = q1Vals ? (q1Vals.meta.ActualIrradiance || 0) : 0;
                const q3 = q3Vals ? (q3Vals.meta.ActualIrradiance || 0) : 0;
                const iqr = q3 - q1;
                const minSafe = q1 - (iqr * 1.5);
                const maxSafe = q3 + (iqr * 1.5);
                finalPoints = rawPoints.filter(pt => {
                    const val = pt.meta.ActualIrradiance || 0;
                    return val >= minSafe && val <= maxSafe;
                });
            }

            if(finalPoints.length > 0) {
                let sumIrr = 0, sumTSRF = 0;
                finalPoints.forEach(pt => {
                    sumIrr += (pt.meta.ActualIrradiance || 0);
                    sumTSRF += (pt.meta.TSRF || 0);
                    APP.validRadPoints.push(pt.id);
                });

                const count = finalPoints.length;
                const avgIrr = sumIrr / count;
                const yieldKwh = (avgIrr / 1000) * (APP.panel.watts / 1000);
                const avgTsrf = sumTSRF / count;

                APP.panelStats.push({
                    id: idx+1,
                    irr: avgIrr,
                    tsrf: avgTsrf,
                    yield: yieldKwh,
                    points: finalPoints.map(p => p.id),
                    stringIdx: APP.panelToString[idx] ?? -1
                });
                totalYield += yieldKwh;
                totalTSRF += avgTsrf;
                panelsWithData++;
            } else {
                APP.panelStats.push({ id: idx+1, irr: 0, tsrf: 0, yield: 0, points: [], stringIdx: -1 });
            }
        });

        // Generate Model A: Independent panel timeseries
        APP.generateIndependentTimeseries();

        // Generate Model B: String-level mismatch timeseries
        APP.generateStringTimeseries();

        // Calculate clipping per inverter
        APP.runEnergyDispatch();

        // Calculate system stats
        const dcCapacity = (APP.geo.length * APP.panel.watts) / 1000;
        const sysTSRF = panelsWithData ? (totalTSRF / panelsWithData) : 0;

        // Compute annual totals for all 3 models
        const indepTotal = APP.panelTimeseries.reduce((sum, series) => {
            return sum + series.reduce((a,b) => a+b, 0) / 2000; // W * 0.5h / 1000 = kWh
        }, 0);
        const stringTotal = APP.stringTimeseries.reduce((sum, series) => {
            return sum + series.reduce((a,b) => a+b, 0) / 2000;
        }, 0);
        const evTotal = APP.eagleViewProduction.annual;
        const mismatchLoss = indepTotal > 0 ? ((indepTotal - stringTotal) / indepTotal * 100) : 0;

        // Verify seasonal TSRF calibration (annual energy should match flat TSRF within ~1%)
        if(!APP.hasShade && indepTotal > 0 && panelsWithData > 0) {
            const avgTsrf = totalTSRF / panelsWithData;
            let flatSum = 0;
            for(let d = 0; d < 365; d++) {
                for(let h = 0; h < 48; h++) {
                    const hour = h / 2;
                    let sf = 0;
                    if(hour >= 6 && hour <= 20) sf = Math.sin((hour - 6) / 14 * Math.PI);
                    flatSum += sf * (0.7 + 0.3 * Math.sin((d - 80) / 365 * 2 * Math.PI));
                }
            }
            const flatEstimate = APP.geo.length * APP.panel.watts * avgTsrf * flatSum / 2000;
            const calibDelta = ((indepTotal - flatEstimate) / flatEstimate * 100);
            APP.log(`Seasonal TSRF: ${indepTotal.toFixed(0)} kWh vs flat ${flatEstimate.toFixed(0)} kWh (${calibDelta > 0 ? '+' : ''}${calibDelta.toFixed(2)}%)`, Math.abs(calibDelta) < 2 ? 'ok' : 'warn');
        }

        // Update UI
        document.getElementById('resCard').style.display = 'block';
        document.getElementById('valIndep').innerText = Math.round(indepTotal).toLocaleString();
        document.getElementById('valString').innerText = Math.round(stringTotal).toLocaleString();
        document.getElementById('valEV').innerText = evTotal > 0 ? Math.round(evTotal).toLocaleString() : 'N/A';
        document.getElementById('valCount').innerText = panelsWithData + " / " + APP.geo.length;
        document.getElementById('valDC').innerText = dcCapacity.toFixed(1) + " kW";
        document.getElementById('valTSRF').innerText = (sysTSRF*100).toFixed(1) + "%";
        document.getElementById('valMismatch').innerText = mismatchLoss.toFixed(1) + "%";

        // Render views
        APP.renderProdTable();
        APP.renderTimeseries();
        APP.renderInverterView();
        APP.renderBatteryView();
        APP.generateAIAnalysis();

        // Update mode
        if(APP.hasShade) {
            document.getElementById('mode-badge').innerText = "FULL SIMULATION";
            document.getElementById('mode-badge').style.color = "#34d399";
        } else {
            document.getElementById('mode-badge').innerText = "SEASONAL ESTIMATE";
            document.getElementById('mode-badge').style.color = "#facc15";
        }

        APP.render();
        APP.log("Analysis complete.", 'ok');
    },

    // ============== MODEL A: INDEPENDENT PANEL TIMESERIES ==============
    generateIndependentTimeseries: () => {
        APP.panelTimeseries = [];
        APP.panelStats.forEach((panel) => {
            const series = new Float32Array(17520);
            const baseTsrf = panel.tsrf || 0.8;
            for(let d = 0; d < 365; d++) {
                const tsrfValue = APP.getSeasonalTSRF(baseTsrf, d);
                for(let h = 0; h < 48; h++) {
                    const hour = h / 2;
                    let solarFactor = 0;
                    if(hour >= 6 && hour <= 20) {
                        solarFactor = Math.sin((hour - 6) / 14 * Math.PI);
                    }
                    const seasonFactor = 0.7 + 0.3 * Math.sin((d - 80) / 365 * 2 * Math.PI);
                    const shadeFactor = APP.getPanelShadeFactorAtTimestep(panel, d * 48 + h);
                    series[d * 48 + h] = APP.panel.watts * solarFactor * seasonFactor * shadeFactor * tsrfValue;
                }
            }
            APP.panelTimeseries.push(series);
        });
        APP.log(`Model A: Generated independent timeseries for ${APP.panelTimeseries.length} panels`, 'ok');
    },

    // ============== MODEL B: STRING-LEVEL MISMATCH TIMESERIES ==============
    generateStringTimeseries: () => {
        APP.stringTimeseries = [];
        if(APP.strings.length === 0) {
            APP.log("No strings configured - Model B skipped", 'warn');
            return;
        }

        const numDiodes = APP.panel.bypassDiodes;
        const vmpPerPanel = APP.panel.vmp;
        const impPanel = APP.panel.imp;

        APP.strings.forEach((str, sIdx) => {
            const series = new Float32Array(17520);
            const panelIndices = str.panels;

            for(let t = 0; t < 17520; t++) {
                const d = Math.floor(t / 48);
                const h = t % 48;
                const hour = h / 2;

                let solarFactor = 0;
                if(hour >= 6 && hour <= 20) {
                    solarFactor = Math.sin((hour - 6) / 14 * Math.PI);
                }
                if(solarFactor <= 0.01) { series[t] = 0; continue; }

                const seasonFactor = 0.7 + 0.3 * Math.sin((d - 80) / 365 * 2 * Math.PI);
                const baseFactor = solarFactor * seasonFactor;

                // For each panel in string, compute current ratio and voltage contribution
                let minCurrentRatio = 1;
                let totalVoltage = 0;
                let anyActive = false;

                panelIndices.forEach(pIdx => {
                    const panel = APP.panelStats[pIdx];
                    if(!panel) return;

                    const shadeFactor = APP.getPanelShadeFactorAtTimestep(panel, t);
                    const shadedFraction = 1 - shadeFactor;
                    const tsrfValue = APP.getSeasonalTSRF(panel.tsrf || 0.8, d);

                    // Bypass diode model: shade distributed across substrings
                    // Each substring covers 1/numDiodes of the panel area
                    // A substring is bypassed when its cells are majority-shaded
                    // Use proportional model: bypassed substrings = floor(shadedFraction * numDiodes)
                    // with remaining partial shade reducing current in the weakest active substring
                    let bypassed = 0;
                    let partialShade = 0;
                    if(shadedFraction <= 0) {
                        bypassed = 0;
                        partialShade = 0;
                    } else {
                        bypassed = Math.min(numDiodes, Math.floor(shadedFraction * numDiodes));
                        // Remaining shade affects the next substring partially
                        const remainingShade = shadedFraction * numDiodes - bypassed;
                        partialShade = remainingShade; // 0 to 1 within the substring
                    }

                    const activeSubstrings = numDiodes - bypassed;
                    // Current ratio: active substrings minus partial shade impact
                    // Partial shade on one substring reduces current proportionally (not a full bypass)
                    const currentRatio = activeSubstrings > 0
                        ? (activeSubstrings - partialShade * 0.5) / numDiodes  // partial shade = 50% current loss in that substring
                        : 0;

                    if(currentRatio > 0) {
                        minCurrentRatio = Math.min(minCurrentRatio, currentRatio);
                        // Voltage: bypassed substrings contribute ~0V, active contribute proportionally
                        totalVoltage += vmpPerPanel * (activeSubstrings / numDiodes) * baseFactor * tsrfValue;
                        anyActive = true;
                    }
                    // Fully bypassed panels contribute ~0V (bypass diode forward voltage negligible)
                });

                if(!anyActive) { series[t] = 0; continue; }

                const stringCurrent = impPanel * baseFactor * minCurrentRatio;
                series[t] = stringCurrent * totalVoltage / baseFactor; // normalize to avoid double-applying baseFactor on current side
                // Simpler: power = Imp * minCurrentRatio * baseFactor * totalVoltage
                // but totalVoltage already has baseFactor baked in, so:
                series[t] = impPanel * minCurrentRatio * totalVoltage;
            }
            APP.stringTimeseries.push(series);
        });
        APP.log(`Model B: Generated string timeseries for ${APP.stringTimeseries.length} strings with bypass diode mismatch`, 'ok');
    },

    // ============== MULTI-INVERTER MANAGEMENT ==============
    addInverter: () => {
        const typeKey = document.getElementById('selInverter').value;
        const invSpec = EQUIPMENT.inverters[typeKey];

        // PW3 pairing rule: isIntegrated inverters only pair with other isIntegrated inverters
        if(APP.inverters.length > 0) {
            const existingIsIntegrated = APP.inverters[0].spec?.isIntegrated || EQUIPMENT.inverters[APP.inverters[0].typeKey]?.isIntegrated;
            const newIsIntegrated = invSpec.isIntegrated;
            if(existingIsIntegrated && !newIsIntegrated) {
                APP.log(`Cannot mix: Powerwall 3 integrated inverters must pair with other PW3 units only`, 'err');
                return;
            }
            if(!existingIsIntegrated && newIsIntegrated) {
                APP.log(`Cannot mix: Powerwall 3 integrated inverters cannot be added to a system with standalone inverters`, 'err');
                return;
            }
        }

        const id = APP.inverters.length;
        APP.inverters.push({
            id,
            typeKey,
            name: `INV-${id + 1}`,
            strings: [],
            spec: invSpec
        });

        // Auto-initialize battery config for PW3 (DC-coupled) inverters
        if(invSpec.isIntegrated) {
            const ess = EQUIPMENT.ess['Tesla_PW3'];
            APP.batteryConfig[id] = {
                essKey: 'Tesla_PW3',
                expansions: 0,
                totalCapacityWh: ess.capacity * 1000,
                totalDcChargeW: ess.dcChargeRate,
                maxDischargeW: ess.power * 1000,
                roundTrip: ess.roundTrip
            };
        }

        APP.log(`Added inverter: ${invSpec.name} as INV-${id+1}`, 'ok');
        APP.renderInverterConfig();
    },

    removeInverter: (invIdx) => {
        const inv = APP.inverters[invIdx];
        // Unassign strings
        inv.strings.forEach(sIdx => { delete APP.stringToInverter[sIdx]; });
        APP.inverters.splice(invIdx, 1);
        // Reindex
        APP.stringToInverter = {};
        APP.inverters.forEach((inv, idx) => {
            inv.id = idx;
            inv.name = `INV-${idx + 1}`;
            inv.strings.forEach(sIdx => { APP.stringToInverter[sIdx] = idx; });
        });
        APP.renderInverterConfig();
        APP.refreshModels();
    },

    assignStringToInverter: (stringIdx, invIdx) => {
        // Remove from previous inverter
        if(APP.stringToInverter[stringIdx] !== undefined) {
            const prevInv = APP.inverters[APP.stringToInverter[stringIdx]];
            if(prevInv) prevInv.strings = prevInv.strings.filter(s => s !== stringIdx);
        }
        APP.inverters[invIdx].strings.push(stringIdx);
        APP.stringToInverter[stringIdx] = invIdx;
        APP.renderInverterConfig();
        APP.refreshModels();
    },

    unassignString: (stringIdx) => {
        if(APP.stringToInverter[stringIdx] !== undefined) {
            const inv = APP.inverters[APP.stringToInverter[stringIdx]];
            if(inv) inv.strings = inv.strings.filter(s => s !== stringIdx);
            delete APP.stringToInverter[stringIdx];
        }
        APP.renderInverterConfig();
        APP.refreshModels();
    },

    renderInverterConfig: () => {
        const container = document.getElementById('invConfigList');
        if(APP.inverters.length === 0) {
            container.innerHTML = '<div style="color:#64748b; font-size:10px; text-align:center; padding:6px;">No inverters configured. Click + Add Inverter.</div>';
            document.getElementById('invUnassigned').style.display = 'none';
            return;
        }

        container.innerHTML = APP.inverters.map((inv, idx) => {
            const spec = inv.spec || EQUIPMENT.inverters[inv.typeKey];
            const stringTags = inv.strings.map(sIdx =>
                `<span class="tag" onclick="APP.unassignString(${sIdx})" title="Click to unassign">S${sIdx+1}</span>`
            ).join('');

            // Build assign dropdown options
            const unassigned = APP.strings
                .map((s, i) => i)
                .filter(i => APP.stringToInverter[i] === undefined);

            let assignHtml = '';
            if(unassigned.length > 0) {
                assignHtml = `<select onchange="if(this.value!=='') APP.assignStringToInverter(parseInt(this.value), ${idx}); this.value='';" style="width:auto; padding:3px; font-size:9px; margin-top:4px;">
                    <option value="">Assign string...</option>
                    ${unassigned.map(i => `<option value="${i}">String ${i+1}</option>`).join('')}
                </select>`;
            }

            // Battery config for integrated (PW3) inverters
            let battHtml = '';
            if(spec.isIntegrated) {
                const ess = EQUIPMENT.ess['Tesla_PW3'];
                const bCfg = APP.batteryConfig[idx] || { expansions: 0 };
                const exp = bCfg.expansions || 0;
                const totalCap = (ess.capacity + exp * ess.expansionCapacity).toFixed(1);
                const dcRate = exp > 0 ? ess.dcChargeRateExpanded : ess.dcChargeRate;
                const totalPower = spec.acPower + dcRate;
                battHtml = `
                <div style="margin-top:6px; padding:6px; background:rgba(251,146,60,0.1); border:1px solid var(--orange); border-radius:4px; font-size:9px;">
                    <div style="font-weight:600; color:var(--orange); margin-bottom:4px;">DC Battery (PW3)</div>
                    <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
                        <span>Expansion Packs:</span>
                        <select onchange="APP.configureBattery(${idx}, parseInt(this.value))" style="width:auto; padding:2px; font-size:9px;">
                            ${[0,1,2,3].map(n => `<option value="${n}" ${n===exp?'selected':''}>${n} (${(ess.capacity + n * ess.expansionCapacity).toFixed(1)} kWh)</option>`).join('')}
                        </select>
                    </div>
                    <div>Capacity: <strong>${totalCap} kWh</strong> | DC Charge: <strong>${(dcRate/1000).toFixed(0)} kW</strong></div>
                    <div>Max DC Throughput: <strong>${(totalPower/1000).toFixed(1)} kW</strong> (${(spec.acPower/1000).toFixed(1)} AC + ${(dcRate/1000).toFixed(0)} DC)</div>
                </div>`;
            }

            return `<div class="inv-cfg-item">
                <div class="inv-cfg-header">
                    <span style="font-weight:600;">${inv.name}: ${spec.name}</span>
                    <button class="btn-sm btn-danger" onclick="APP.removeInverter(${idx})" style="padding:2px 6px; font-size:8px;">X</button>
                </div>
                <div style="font-size:9px; color:#64748b;">AC: ${(spec.acPower/1000).toFixed(1)}kW | MPPT: ${spec.mpptMin}-${spec.mpptMax}V | Ch: ${spec.channels}</div>
                <div class="inv-cfg-assign">${stringTags || '<span style="color:#64748b; font-size:9px;">No strings</span>'}</div>
                ${assignHtml}
                ${battHtml}
            </div>`;
        }).join('');

        // Show unassigned strings warning
        const unassigned = APP.strings
            .map((s, i) => i)
            .filter(i => APP.stringToInverter[i] === undefined);

        const unEl = document.getElementById('invUnassigned');
        if(unassigned.length > 0 && APP.strings.length > 0) {
            unEl.style.display = 'block';
            unEl.innerHTML = `<div class="inv-unassigned">Unassigned: ${unassigned.map(i => `S${i+1}`).join(', ')}</div>`;
        } else {
            unEl.style.display = 'none';
        }
    },

    // ============== BATTERY CONFIGURATION ==============
    configureBattery: (invIdx, expansions) => {
        const ess = EQUIPMENT.ess['Tesla_PW3'];
        APP.batteryConfig[invIdx] = {
            essKey: 'Tesla_PW3',
            expansions: expansions,
            totalCapacityWh: (ess.capacity + expansions * ess.expansionCapacity) * 1000,
            totalDcChargeW: expansions > 0 ? ess.dcChargeRateExpanded : ess.dcChargeRate,
            maxDischargeW: ess.power * 1000 + expansions * ess.expansionPower,
            roundTrip: ess.roundTrip
        };
        APP.renderInverterConfig();
        APP.log(`Inv ${invIdx+1} battery: ${((ess.capacity + expansions * ess.expansionCapacity)).toFixed(1)} kWh, DC charge ${(APP.batteryConfig[invIdx].totalDcChargeW/1000).toFixed(0)} kW`, 'ok');
        if(APP.stringTimeseries.length > 0) {
            APP.runEnergyDispatch();
            APP.renderInverterView();
            APP.renderBatteryView();
        }
    },

    // ============== ENERGY DISPATCH (replaces calculateClipping) ==============
    // CO/XCEL COMPLIANCE: Per Colorado AHJ and Xcel Energy interconnection rules:
    //   1. Batteries can ONLY charge from PV (never from grid)
    //   2. Batteries can NEVER export to grid (only power house loads)
    //   3. PV excess CAN export to grid (net metered at retail rate, up to 10kW residential)
    // Battery discharge reduces home deficit only; it never increases grid export surplus.
    // All battery charge paths source from solar DC excess or solar AC surplus.
    runEnergyDispatch: () => {
        APP.inverterTimeseries = [];
        APP.clippingEvents = [];
        APP.batteryChargingEvents = []; // DC battery charging events (NOT clipping)
        APP.batteryState = [];
        let totalSystemClipped = 0;
        let totalSystemGen = 0;

        // Reset energy balance
        const eb = APP.energyBalance = {
            totalProduction: 0, selfConsumed: 0, gridExport: 0, gridImport: 0,
            batteryCharged: 0, batteryDischarged: 0, batteryLosses: 0, curtailed: 0, clipped: 0,
            batteryExportedToGrid: 0 // CO compliance: must always be 0
        };

        const mode = APP.homeConsumption.priorityMode;
        const hasConsumption = APP.homeConsumption.enabled && APP.homeConsumption.profile;
        const sqrtEff = {}; // cache sqrt(roundTrip) per inverter

        // TOU peak hours: 4pm-9pm (slots 32-41) for time-of-use mode
        const isPeakHour = (t) => { const slot = t % 48; return slot >= 32 && slot <= 41; };

        // PHASE 0: Initialize per-inverter data structures
        APP.inverters.forEach((inv, invIdx) => {
            const spec = inv.spec || EQUIPMENT.inverters[inv.typeKey];
            APP.inverterTimeseries.push(new Array(17520));

            // Initialize battery state for DC-coupled (PW3) inverters
            const bCfg = APP.batteryConfig[invIdx];
            if(spec.isIntegrated && bCfg && bCfg.totalCapacityWh > 0) {
                sqrtEff[invIdx] = Math.sqrt(bCfg.roundTrip);
                APP.batteryState[invIdx] = {
                    socWh: new Float32Array(17520),
                    chargeW: new Float32Array(17520),
                    dischargeW: new Float32Array(17520),
                    config: bCfg
                };
                // Start at backup reserve level (typical morning state after overnight discharge)
                APP.batteryState[invIdx].socWh[0] = bCfg.totalCapacityWh * Math.max(0.2, APP.homeConsumption.backupReservePct / 100);
            } else {
                APP.batteryState[invIdx] = null;
            }
        });

        // System-level dispatch timeseries
        const dispatchTs = new Array(17520);

        // MAIN DISPATCH LOOP: Single pass through all 17,520 timesteps
        for(let t = 0; t < 17520; t++) {

            // PHASE 1: Compute raw DC input per inverter
            const dcInputs = [];
            APP.inverters.forEach((inv, invIdx) => {
                let dcInput = 0;
                inv.strings.forEach(sIdx => {
                    if(APP.stringTimeseries[sIdx]) dcInput += APP.stringTimeseries[sIdx][t];
                });
                dcInputs[invIdx] = dcInput;
            });

            // PHASE 2: DC Battery Charging (PW3 only, BEFORE inverter clip)
            // Key: DC power going to battery is NOT clipping. The combined throughput
            // of a PW3 is acLimit + dcChargeRate (e.g. 11.5kW AC + 5kW DC = 16.5kW).
            // True clipping only occurs when raw DC exceeds this combined capacity
            // OR when the battery is full and DC exceeds AC-only limit.
            const rawDcInputs = dcInputs.slice(); // save raw DC for clipping classification

            APP.inverters.forEach((inv, invIdx) => {
                const spec = inv.spec || EQUIPMENT.inverters[inv.typeKey];
                const bState = APP.batteryState[invIdx];
                if(!bState || !spec.isIntegrated) return;

                const bCfg = bState.config;
                const prevSoC = t > 0 ? bState.socWh[t-1] : bState.socWh[0];
                const acCapW = spec.acPower * APP.clippingThreshold;
                const dcForAC = acCapW / spec.efficiency; // DC watts needed for full AC output

                const excessDC = dcInputs[invIdx] - dcForAC;
                if(excessDC > 0 && prevSoC < bCfg.totalCapacityWh) {
                    const headroom = (bCfg.totalCapacityWh - prevSoC) / (0.5 * sqrtEff[invIdx]); // max watts to fill in 30min
                    const dcCharge = Math.min(excessDC, bCfg.totalDcChargeW, headroom);
                    bState.chargeW[t] = dcCharge;
                    bState.socWh[t] = prevSoC + dcCharge * 0.5 * sqrtEff[invIdx];
                    dcInputs[invIdx] -= dcCharge; // absorbed into battery
                    eb.batteryCharged += dcCharge * 0.5 / 1000; // kWh
                    eb.batteryLosses += dcCharge * 0.5 * (1 - sqrtEff[invIdx]) / 1000;
                } else {
                    bState.socWh[t] = prevSoC;
                }
            });

            // PHASE 3: Inverter AC Clipping (per-inverter, on reduced DC input)
            // After DC battery charging absorbed what it could, check if remaining DC
            // still exceeds AC limit. This is TRUE clipping — the battery couldn't absorb it.
            let totalACOutput = 0;
            APP.inverters.forEach((inv, invIdx) => {
                const spec = inv.spec || EQUIPMENT.inverters[inv.typeKey];
                const acLimit = spec.acPower * APP.clippingThreshold;
                const eff = spec.efficiency;
                const bState = APP.batteryState[invIdx];
                const dcToBatt = bState ? (bState.chargeW[t] || 0) : 0;

                let acOutput = dcInputs[invIdx] * eff;
                let clippedW = 0;
                let isBatteryCharging = false; // power absorbed by battery, NOT clipped

                if(acOutput > acLimit) {
                    clippedW = acOutput - acLimit;
                    acOutput = acLimit;
                    totalSystemClipped += clippedW;
                    eb.clipped += clippedW / 2000;
                }

                // Classify: was the original raw DC within combined AC+DC capacity?
                // If yes, any "clipping" at AC limit is actually due to battery being full,
                // but we still had capacity on the combined bus — the battery just couldn't take more.
                const rawDC = rawDcInputs[invIdx];
                const combinedLimit = (acLimit / eff) + (bState ? bState.config.totalDcChargeW : 0);
                if(dcToBatt > 0 && rawDC <= combinedLimit) {
                    isBatteryCharging = true; // DC was within combined capacity, battery absorbed excess
                }

                totalSystemGen += dcInputs[invIdx] + dcToBatt; // total DC includes what went to battery
                APP.inverterTimeseries[invIdx][t] = {
                    dcInput: rawDcInputs[invIdx], // report RAW DC input (before battery absorption)
                    dcAfterBattery: dcInputs[invIdx], // DC after battery took its share
                    acOutput: acOutput,
                    clippedW: clippedW,
                    dcToBattery: dcToBatt,
                    isBatteryCharging: isBatteryCharging, // true = excess went to battery, not clipped
                    isTrueClip: clippedW > 0 && !isBatteryCharging, // true = battery full or no battery, inverter limit hit
                    curtailedW: 0
                };
                totalACOutput += acOutput;
            });

            // PHASE 4: System Dispatch (home consumption + battery discharge + export limit)
            const homeLoad = hasConsumption ? APP.homeConsumption.profile[t] : 0;
            let selfConsumed = Math.min(totalACOutput, homeLoad);
            let surplus = totalACOutput - selfConsumed;
            let deficit = homeLoad - selfConsumed;

            // Battery discharge to cover deficit
            let totalDischarge = 0;
            if(deficit > 0) {
                const dischargeAllowed = (mode === 'export') ? (totalACOutput === 0) : true; // export-first: discharge for home loads only when no solar (nighttime). CO compliant: discharge never exports.
                const touBoost = (mode === 'tou' && isPeakHour(t)) ? 1.5 : 1.0; // TOU: discharge more aggressively during peak

                if(dischargeAllowed) {
                    APP.inverters.forEach((inv, invIdx) => {
                        if(deficit <= 0) return;
                        const bState = APP.batteryState[invIdx];
                        if(!bState) return;
                        const bCfg = bState.config;
                        const soc = bState.socWh[t];
                        // Reserve battery backup (configurable, Tesla default 20%)
                        const reserveWh = bCfg.totalCapacityWh * (APP.homeConsumption.backupReservePct / 100);
                        const availableWh = Math.max(0, soc - reserveWh);
                        const maxDischW = Math.min(bCfg.maxDischargeW * touBoost, availableWh / (0.5 / sqrtEff[invIdx]));
                        const discharge = Math.min(deficit, maxDischW);
                        if(discharge > 0) {
                            bState.dischargeW[t] = discharge;
                            bState.socWh[t] -= discharge * 0.5 / sqrtEff[invIdx];
                            deficit -= discharge;
                            totalDischarge += discharge;
                            eb.batteryDischarged += discharge * 0.5 / 1000;
                            eb.batteryLosses += discharge * 0.5 * (1 - sqrtEff[invIdx]) / 1000;
                        }
                    });
                }
            }

            // AC-coupled battery charge from surplus (for future AC-coupled ESS support)
            // Currently all batteries are DC-coupled (PW3), but this handles the AC path
            if(surplus > 0 && mode !== 'export') {
                APP.inverters.forEach((inv, invIdx) => {
                    if(surplus <= 0) return;
                    const bState = APP.batteryState[invIdx];
                    if(!bState) return;
                    const bCfg = bState.config;
                    const soc = bState.socWh[t];
                    const headroom = bCfg.totalCapacityWh - soc;
                    if(headroom <= 0) return;
                    // AC-side charge (only if DC didn't fill it)
                    const dcAlreadyCharged = bState.chargeW[t] || 0;
                    const maxAdditional = Math.min(bCfg.totalDcChargeW - dcAlreadyCharged, headroom / (0.5 * sqrtEff[invIdx]));
                    if(maxAdditional <= 0) return;
                    const acCharge = Math.min(surplus, maxAdditional);
                    bState.chargeW[t] += acCharge;
                    bState.socWh[t] += acCharge * 0.5 * sqrtEff[invIdx];
                    surplus -= acCharge;
                    eb.batteryCharged += acCharge * 0.5 / 1000;
                    eb.batteryLosses += acCharge * 0.5 * (1 - sqrtEff[invIdx]) / 1000;
                });
            }

            // Export limit check: applies to NET surplus (after home consumption & battery)
            let curtailedW = 0;
            if(APP.exportLimitW > 0 && surplus > APP.exportLimitW) {
                curtailedW = surplus - APP.exportLimitW;

                // Before curtailing, try to push excess to battery if capacity available
                APP.inverters.forEach((inv, invIdx) => {
                    if(curtailedW <= 0) return;
                    const bState = APP.batteryState[invIdx];
                    if(!bState) return;
                    const bCfg = bState.config;
                    const headroom = bCfg.totalCapacityWh - bState.socWh[t];
                    if(headroom <= 0) return;
                    const maxCharge = Math.min(curtailedW, bCfg.totalDcChargeW - (bState.chargeW[t] || 0), headroom / (0.5 * sqrtEff[invIdx]));
                    if(maxCharge > 0) {
                        bState.chargeW[t] += maxCharge;
                        bState.socWh[t] += maxCharge * 0.5 * sqrtEff[invIdx];
                        curtailedW -= maxCharge;
                        surplus -= maxCharge;
                        eb.batteryCharged += maxCharge * 0.5 / 1000;
                    }
                });

                if(curtailedW > 0) {
                    surplus -= curtailedW;
                    eb.curtailed += curtailedW / 2000;
                    // Pro-rate curtailment across inverters
                    if(totalACOutput > 0) {
                        APP.inverters.forEach((inv, invIdx) => {
                            const ts = APP.inverterTimeseries[invIdx][t];
                            const ratio = ts.acOutput / totalACOutput;
                            ts.curtailedW = curtailedW * ratio;
                        });
                    }
                }
            }

            // TOU mode: during off-peak, charge battery from surplus more aggressively
            if(mode === 'tou' && !isPeakHour(t) && surplus > 0) {
                APP.inverters.forEach((inv, invIdx) => {
                    if(surplus <= 0) return;
                    const bState = APP.batteryState[invIdx];
                    if(!bState) return;
                    const bCfg = bState.config;
                    const headroom = bCfg.totalCapacityWh - bState.socWh[t];
                    if(headroom <= 0) return;
                    const maxCharge = Math.min(surplus, bCfg.totalDcChargeW - (bState.chargeW[t] || 0), headroom / (0.5 * sqrtEff[invIdx]));
                    if(maxCharge > 0) {
                        bState.chargeW[t] += maxCharge;
                        bState.socWh[t] += maxCharge * 0.5 * sqrtEff[invIdx];
                        surplus -= maxCharge;
                        eb.batteryCharged += maxCharge * 0.5 / 1000;
                    }
                });
            }

            // PHASE 5: Record dispatch results
            eb.totalProduction += totalACOutput / 2000;
            eb.selfConsumed += selfConsumed / 2000;
            eb.gridExport += surplus / 2000;
            eb.gridImport += deficit / 2000;

            dispatchTs[t] = {
                totalAC: totalACOutput,
                homeLoad: homeLoad,
                selfConsumed: selfConsumed,
                gridExport: surplus,
                gridImport: deficit,
                batteryDischarge: totalDischarge,
                curtailed: curtailedW
            };
        }

        // Event detection (post-processing for cleaner event boundaries)
        // Separate TRUE clipping events from battery charging events
        APP.inverters.forEach((inv, invIdx) => {
            // True clipping events: battery full or no battery, inverter limit exceeded
            let clipStart = -1, clipPeakW = 0, clipTotalWh = 0;
            for(let t = 0; t < 17520; t++) {
                const ts = APP.inverterTimeseries[invIdx][t];
                if(ts.isTrueClip && ts.clippedW > 0) {
                    if(clipStart < 0) { clipStart = t; clipPeakW = 0; clipTotalWh = 0; }
                    clipPeakW = Math.max(clipPeakW, ts.clippedW);
                    clipTotalWh += ts.clippedW / 2000;
                } else {
                    if(clipStart >= 0) {
                        APP.clippingEvents.push(APP.buildClipEvent(invIdx, inv.name, clipStart, t - 1, clipPeakW, clipTotalWh));
                        clipStart = -1;
                    }
                }
            }
            if(clipStart >= 0) {
                APP.clippingEvents.push(APP.buildClipEvent(invIdx, inv.name, clipStart, 17519, clipPeakW, clipTotalWh));
            }

            // Battery charging events: DC excess absorbed by battery (NOT clipping)
            let battStart = -1, battPeakW = 0, battTotalWh = 0;
            for(let t = 0; t < 17520; t++) {
                const ts = APP.inverterTimeseries[invIdx][t];
                if(ts.dcToBattery > 0) {
                    if(battStart < 0) { battStart = t; battPeakW = 0; battTotalWh = 0; }
                    battPeakW = Math.max(battPeakW, ts.dcToBattery);
                    battTotalWh += ts.dcToBattery / 2000;
                } else {
                    if(battStart >= 0) {
                        APP.batteryChargingEvents.push({
                            invIdx, invName: inv.name, startSlot: battStart, endSlot: t - 1,
                            peakW: battPeakW, totalKwh: battTotalWh, type: 'battery_charging',
                            date: APP.buildClipEvent(invIdx, inv.name, battStart, t - 1, battPeakW, battTotalWh).date
                        });
                        battStart = -1;
                    }
                }
            }
            if(battStart >= 0) {
                APP.batteryChargingEvents.push({
                    invIdx, invName: inv.name, startSlot: battStart, endSlot: 17519,
                    peakW: battPeakW, totalKwh: battTotalWh, type: 'battery_charging',
                    date: APP.buildClipEvent(invIdx, inv.name, battStart, 17519, battPeakW, battTotalWh).date
                });
            }
        });

        APP.clippingLoss = totalSystemGen > 0 ? (totalSystemClipped / totalSystemGen * 100) : 0;
        APP.exportCurtailed = eb.curtailed;
        APP.dispatchTimeseries = dispatchTs;

        // Energy balance validation: Production + GridImport ≈ SelfConsumed + GridExport + BatteryLosses + Curtailed + Clipped
        const balanceIn = eb.totalProduction + eb.gridImport;
        const netBattery = eb.batteryCharged - eb.batteryDischarged;
        const balanceOut = eb.selfConsumed + eb.gridExport + eb.batteryLosses + eb.curtailed + eb.clipped + netBattery;
        const balanceDelta = Math.abs(balanceIn - balanceOut);
        if(balanceDelta > 1) {
            APP.log(`Energy balance warning: In=${balanceIn.toFixed(1)} Out=${balanceOut.toFixed(1)} Δ=${balanceDelta.toFixed(1)} kWh`, 'warn');
        }

        // CO/Xcel compliance check
        if(eb.batteryExportedToGrid > 0.01) {
            APP.log(`CO COMPLIANCE ERROR: Battery exported ${eb.batteryExportedToGrid.toFixed(1)} kWh to grid. Per Xcel rules, battery may only power house loads.`, 'err');
        }

        // Compute battery analytics (shared by Battery tab and AI analysis)
        APP.computeBatteryAnalytics(dispatchTs, isPeakHour);

        // Update energy balance UI
        APP.updateEnergyBalanceUI();

        const trueClipCount = APP.clippingEvents.length;
        const battChgCount = APP.batteryChargingEvents.length;
        APP.log(`Energy dispatch complete. Self-consumption: ${(eb.selfConsumed).toFixed(0)} kWh, Export: ${(eb.gridExport).toFixed(0)} kWh, Battery: ${(eb.batteryCharged).toFixed(0)} kWh charged`, 'ok');
        if(trueClipCount > 0 || battChgCount > 0) {
            APP.log(`Events: ${trueClipCount} true clipping${trueClipCount !== 1 ? 's' : ''}, ${battChgCount} battery charging sessions (not clipping)`, trueClipCount > 0 ? 'warn' : 'ok');
        }
    },

    // ============== BATTERY ANALYTICS ENGINE ==============
    // Computed once after dispatch, consumed by Battery Tab and AI Analysis
    computeBatteryAnalytics: (dispatchTs, isPeakHour) => {
        const eb = APP.energyBalance;
        const hasBattery = APP.batteryState.some(b => b !== null);
        const hasConsumption = APP.homeConsumption.enabled && APP.homeConsumption.profile;
        const totalCapWh = hasBattery ? APP.batteryState.filter(b => b).reduce((s, b) => s + b.config.totalCapacityWh, 0) : 0;
        const totalCapKwh = totalCapWh / 1000;
        const annualCycles = totalCapKwh > 0 ? (eb.batteryCharged / totalCapKwh) : 0;
        const rates = APP.utilityRates;

        const a = APP.batteryAnalytics = {};

        // Grid Independence
        const totalLoad = eb.selfConsumed + eb.gridImport;
        a.gridIndependencePct = totalLoad > 0 ? ((totalLoad - eb.gridImport) / totalLoad * 100) : 0;

        // Overnight Coverage (6pm slot 36 to 6am slot 12 next day)
        a.overnight = { nightsCovered: 0, nightsTotal: 0, totalLoadKwh: 0, totalBattKwh: 0, totalGridKwh: 0, summerCovered: 0, summerTotal: 0, winterCovered: 0, winterTotal: 0 };
        if(hasBattery && hasConsumption && dispatchTs) {
            for(let d = 0; d < 364; d++) {
                let nightLoad = 0, nightBattDisch = 0, nightGrid = 0;
                // Evening: slots 36-47 of day d
                for(let s = d * 48 + 36; s < d * 48 + 48 && s < 17520; s++) {
                    const dt = dispatchTs[s];
                    if(dt) { nightLoad += dt.homeLoad; nightBattDisch += dt.batteryDischarge; nightGrid += dt.gridImport; }
                }
                // Morning: slots 0-11 of day d+1
                for(let s = (d + 1) * 48; s < (d + 1) * 48 + 12 && s < 17520; s++) {
                    const dt = dispatchTs[s];
                    if(dt) { nightLoad += dt.homeLoad; nightBattDisch += dt.batteryDischarge; nightGrid += dt.gridImport; }
                }
                const nightLoadKwh = nightLoad / 2000;
                const nightBattKwh = nightBattDisch / 2000;
                const nightGridKwh = nightGrid / 2000;
                if(nightLoadKwh > 0.01) {
                    a.overnight.nightsTotal++;
                    a.overnight.totalLoadKwh += nightLoadKwh;
                    a.overnight.totalBattKwh += nightBattKwh;
                    a.overnight.totalGridKwh += nightGridKwh;
                    const covered = nightGridKwh < 0.1;
                    if(covered) a.overnight.nightsCovered++;
                    // Seasonal: summer = May-Sep (d 121-273), winter = Nov-Feb (d 305-365, 0-59)
                    const isSummer = (d >= 121 && d <= 273);
                    const isWinter = (d >= 305 || d <= 59);
                    if(isSummer) { a.overnight.summerTotal++; if(covered) a.overnight.summerCovered++; }
                    if(isWinter) { a.overnight.winterTotal++; if(covered) a.overnight.winterCovered++; }
                }
            }
        }

        // Hourly Grid Dependency (24 buckets)
        a.hourly = { solar: new Float32Array(24), battery: new Float32Array(24), grid: new Float32Array(24), load: new Float32Array(24) };
        if(dispatchTs) {
            for(let t = 0; t < 17520; t++) {
                const hour = Math.floor((t % 48) / 2);
                const dt = dispatchTs[t];
                if(dt) {
                    a.hourly.solar[hour] += Math.min(dt.totalAC, dt.homeLoad) / 2000; // solar serving home
                    a.hourly.battery[hour] += dt.batteryDischarge / 2000;
                    a.hourly.grid[hour] += dt.gridImport / 2000;
                    a.hourly.load[hour] += dt.homeLoad / 2000;
                }
            }
        }

        // Monthly Breakdown (12 entries)
        a.monthly = [];
        for(let m = 0; m < 12; m++) {
            const ds = Math.floor((new Date(2024, m, 1) - new Date(2024, 0, 1)) / 86400000);
            const de = Math.min(365, Math.floor((new Date(2024, m + 1, 1) - new Date(2024, 0, 1)) / 86400000));
            let charged = 0, discharged = 0, avgSocSum = 0, socCount = 0, gridImp = 0, selfCon = 0, prod = 0;
            for(let d = ds; d < de; d++) {
                for(let h = 0; h < 48; h++) {
                    const t = d * 48 + h;
                    APP.batteryState.forEach(b => {
                        if(!b) return;
                        charged += (b.chargeW[t] || 0) * 0.5 / 1000;
                        discharged += (b.dischargeW[t] || 0) * 0.5 / 1000;
                        avgSocSum += b.socWh[t]; socCount++;
                    });
                    if(dispatchTs && dispatchTs[t]) {
                        gridImp += dispatchTs[t].gridImport / 2000;
                        selfCon += dispatchTs[t].selfConsumed / 2000;
                        prod += dispatchTs[t].totalAC / 2000;
                    }
                }
            }
            const monthCycles = totalCapKwh > 0 ? (charged / totalCapKwh) : 0;
            const avgSocPct = (socCount > 0 && totalCapWh > 0) ? (avgSocSum / socCount / totalCapWh * 100) : 0;
            const selfPct = prod > 0 ? (selfCon / prod * 100) : 0;
            a.monthly.push({ charged, discharged, cycles: monthCycles, avgSocPct, gridImport: gridImp, selfConsumedPct: selfPct, production: prod });
        }

        // Economic Value: peak-hour grid import avoided by battery
        a.economic = { peakDischKwh: 0, peakGridAvoidedKwh: 0, annualSavings: 0, withoutBatteryGridKwh: 0 };
        if(hasBattery && dispatchTs && isPeakHour) {
            for(let t = 0; t < 17520; t++) {
                if(isPeakHour(t)) {
                    const dt = dispatchTs[t];
                    if(dt) {
                        a.economic.peakDischKwh += dt.batteryDischarge / 2000;
                    }
                }
            }
            // Battery discharge during peak hours avoids expensive grid import
            a.economic.peakGridAvoidedKwh = a.economic.peakDischKwh;
            a.economic.annualSavings = a.economic.peakGridAvoidedKwh * (rates.peak - rates.standard);
            a.economic.withoutBatteryGridKwh = eb.gridImport + eb.batteryDischarged; // without battery, all discharge would be grid import
        }

        // Degradation Projection (2.5%/yr, PW3 LFP chemistry, 70% warranty floor at 10yr)
        a.degradation = [];
        for(let yr = 1; yr <= 10; yr++) {
            const retainedPct = Math.max(70, 100 - 2.5 * yr);
            const capKwh = totalCapKwh * (retainedPct / 100);
            const cumCycles = annualCycles * yr;
            const warrantyOk = retainedPct >= 70 && cumCycles < 10000;
            a.degradation.push({ year: yr, retainedPct, capacityKwh: capKwh, estCycles: annualCycles, cumCycles, warrantyOk });
        }

        // Efficiency breakdown
        a.efficiency = {
            dcChargeEff: Math.sqrt(APP.batteryState.find(b => b)?.config.roundTrip || 0.92) * 100,
            dischargeEff: Math.sqrt(APP.batteryState.find(b => b)?.config.roundTrip || 0.92) * 100,
            effectiveRoundTrip: eb.batteryCharged > 0 ? (eb.batteryDischarged / eb.batteryCharged * 100) : 0,
            totalLossKwh: eb.batteryLosses,
            lossPctOfProduction: eb.totalProduction > 0 ? (eb.batteryLosses / eb.totalProduction * 100) : 0
        };
    },

    updateEnergyBalanceUI: () => {
        const eb = APP.energyBalance;
        const hasData = eb.totalProduction > 0;
        const hasBattery = APP.batteryState.some(b => b !== null);
        const hasConsumption = APP.homeConsumption.enabled;

        const row1 = document.getElementById('energyBalanceRow');
        const row2 = document.getElementById('energyFlowRow');

        if(hasData && (hasConsumption || hasBattery)) {
            row1.style.display = '';
            row2.style.display = '';

            const selfPct = eb.totalProduction > 0 ? (eb.selfConsumed / eb.totalProduction * 100) : 0;
            const battCycles = hasBattery ?
                (eb.batteryCharged / (APP.batteryState.filter(b=>b).reduce((a,b) => a + b.config.totalCapacityWh, 0) / 1000) || 0) : 0;

            document.getElementById('valSelfConsume').innerText = selfPct.toFixed(1) + '%';
            document.getElementById('valBattUtil').innerText = hasBattery ? battCycles.toFixed(0) + ' cyc' : 'N/A';
            document.getElementById('valGridExport').innerText = Math.round(eb.gridExport).toLocaleString();
            document.getElementById('valBattStored').innerText = Math.round(eb.batteryCharged).toLocaleString();
        } else {
            row1.style.display = 'none';
            row2.style.display = 'none';
        }
    },

    buildClipEvent: (invId, invName, startStep, endStep, peakW, totalWh) => {
        const startDay = Math.floor(startStep / 48);
        const startSlot = startStep % 48;
        const endDay = Math.floor(endStep / 48);
        const endSlot = endStep % 48;

        const d = new Date(2024, 0, startDay + 1);
        const dateStr = d.toLocaleDateString('default', { month: 'short', day: 'numeric' });

        const fmtTime = (slot) => `${Math.floor(slot/2)}:${(slot%2)*30 || '00'}`;

        return {
            inverterId: invId,
            inverterName: invName,
            startStep, endStep,
            durationMin: (endStep - startStep + 1) * 30,
            peakClipW: peakW,
            totalClipWh: totalWh,
            date: dateStr,
            day: startDay,
            startTime: fmtTime(startSlot),
            endTime: fmtTime(endSlot + 1)
        };
    },

    // ============== STRINGING ==============
    newString: () => {
        APP.currentString = [];
        APP.activeStringIdx = APP.strings.length;
        document.getElementById('currentStringInfo').innerHTML = `
            <div style="color:var(--purple);">String ${APP.strings.length + 1}</div>
            <div>Panels: 0</div>
            <div>Click panels to add...</div>
        `;
        APP.log(`Creating String ${APP.strings.length + 1}`);
    },

    finishString: () => {
        if(APP.currentString.length === 0) return;

        APP.strings.push({
            panels: [...APP.currentString],
            color: STRING_COLORS[APP.strings.length % STRING_COLORS.length]
        });

        APP.currentString.forEach(idx => {
            APP.panelToString[idx] = APP.strings.length - 1;
        });

        APP.log(`String ${APP.strings.length} complete: ${APP.currentString.length} panels`, 'ok');
        APP.currentString = [];
        APP.activeStringIdx = -1;
        APP.renderStringList();
        APP.recalcStrings();
        APP.renderStringView();
        APP.renderInverterConfig();
        APP.refreshModels();
    },

    panelClick: (idx) => {
        if(APP.activeStringIdx < 0) {
            const panel = APP.panelStats[idx];
            if(panel) {
                APP.log(`Panel ${idx+1}: ${(panel.irr/1000).toFixed(0)} W/m2, TSRF: ${(panel.tsrf*100).toFixed(1)}%`);
            }
            return;
        }

        if(!APP.currentString.includes(idx) && !APP.panelToString.hasOwnProperty(idx)) {
            APP.currentString.push(idx);
            APP.updateCurrentStringInfo();
            APP.renderStringView();
        }
    },

    updateCurrentStringInfo: () => {
        const el = document.getElementById('currentStringInfo');
        const electrical = APP.calculateStringElectrical(APP.currentString);

        el.innerHTML = `
            <div style="color:var(--purple); font-weight:600;">String ${APP.strings.length + 1}</div>
            <div>Panels: ${APP.currentString.length}</div>
            <div>Voc (cold): ${electrical.vocCold.toFixed(1)}V</div>
            <div>Vmp: ${electrical.vmp.toFixed(1)}V</div>
            <div>Power: ${(electrical.power/1000).toFixed(2)}kW</div>
            ${electrical.warning ? `<div style="color:var(--warn);">${electrical.warning}</div>` : ''}
        `;
    },

    calculateStringElectrical: (panelIndices) => {
        if(!APP.panel || !APP.inverter) return { vocCold: 0, vmp: 0, power: 0 };

        const n = panelIndices.length;
        const tempMin = parseFloat(document.getElementById('tempMin').value) || -20;
        const tempMax = parseFloat(document.getElementById('tempMax').value) || 45;

        const vocCold = n * APP.panel.voc * (1 + APP.panel.tempCoVoc * (tempMin - 25));
        const vmpHot = n * APP.panel.vmp * (1 + APP.panel.tempCoVoc * (tempMax - 25));
        const vmp = n * APP.panel.vmp;
        const power = n * APP.panel.watts;
        const isc = APP.panel.isc * (1 + APP.panel.tempCoIsc * (tempMax - 25));

        let warning = null;
        if(vocCold > APP.inverter.mpptMax) {
            warning = `Voc exceeds inverter max (${APP.inverter.mpptMax}V)`;
        } else if(vmpHot < APP.inverter.mpptMin) {
            warning = `Vmp below inverter min (${APP.inverter.mpptMin}V)`;
        } else if(isc > APP.inverter.maxIsc) {
            warning = `Isc exceeds inverter max (${APP.inverter.maxIsc}A)`;
        }

        return { vocCold, vmpHot, vmp, power, isc, imp: APP.panel.imp, warning };
    },

    recalcStrings: () => {
        APP.strings.forEach((str) => {
            str.electrical = APP.calculateStringElectrical(str.panels);
        });
        APP.renderStringList();
        APP.renderInverterView();
    },

    renderStringList: () => {
        const el = document.getElementById('stringList');
        if(APP.strings.length === 0) {
            el.innerHTML = '<div style="color:#64748b; font-size:11px; text-align:center; padding:10px;">No strings configured</div>';
            return;
        }

        el.innerHTML = APP.strings.map((str, idx) => `
            <div class="string-item ${APP.activeStringIdx === idx ? 'active' : ''}" onclick="APP.selectString(${idx})">
                <div style="display:flex; align-items:center;">
                    <div class="string-color" style="background:${str.color}"></div>
                    <span>String ${idx+1}</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px;">
                    <span>${str.panels.length} panels</span>
                    <button class="btn-sm btn-danger" onclick="event.stopPropagation(); APP.removeString(${idx})" style="padding:1px 5px; font-size:8px; width:auto;">✕</button>
                </div>
            </div>
        `).join('');
    },

    selectString: (idx) => {
        APP.activeStringIdx = idx;
        APP.renderStringList();

        const str = APP.strings[idx];
        const elec = str.electrical || APP.calculateStringElectrical(str.panels);

        document.getElementById('stringElectrical').innerHTML = `
            <div style="margin-bottom:6px; color:${str.color}; font-weight:600;">String ${idx+1}</div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                <div>Panels: ${str.panels.length}</div>
                <div>Power: ${(elec.power/1000).toFixed(2)}kW</div>
                <div>Voc (cold): ${elec.vocCold.toFixed(1)}V</div>
                <div>Vmp (hot): ${elec.vmpHot.toFixed(1)}V</div>
                <div>Isc: ${elec.isc.toFixed(2)}A</div>
                <div>Imp: ${elec.imp.toFixed(2)}A</div>
            </div>
            ${elec.warning ? `<div style="margin-top:8px; color:var(--warn); font-size:10px;">${elec.warning}</div>` : ''}
        `;
    },

    autoString: () => {
        if(!APP.panelStats.length) {
            APP.log("Run analysis first", 'warn');
            return;
        }

        const tempMin = parseFloat(document.getElementById('tempMin').value) || -20;
        const vocCold = APP.panel.voc * (1 + APP.panel.tempCoVoc * (tempMin - 25));
        const maxPerString = Math.floor(APP.inverter.mpptMax / vocCold);
        const optimalPerString = Math.max(8, Math.min(maxPerString - 1, 14));

        const sortedIndices = APP.panelStats
            .map((p, i) => ({ idx: i, tsrf: p.tsrf }))
            .filter(p => !APP.panelToString.hasOwnProperty(p.idx))
            .sort((a, b) => b.tsrf - a.tsrf)
            .map(p => p.idx);

        while(sortedIndices.length >= optimalPerString) {
            const stringPanels = sortedIndices.splice(0, optimalPerString);
            APP.strings.push({
                panels: stringPanels,
                color: STRING_COLORS[APP.strings.length % STRING_COLORS.length]
            });
            stringPanels.forEach(idx => {
                APP.panelToString[idx] = APP.strings.length - 1;
            });
        }

        if(sortedIndices.length > 0) {
            APP.strings.push({
                panels: sortedIndices,
                color: STRING_COLORS[APP.strings.length % STRING_COLORS.length]
            });
            sortedIndices.forEach(idx => {
                APP.panelToString[idx] = APP.strings.length - 1;
            });
        }

        APP.log(`Auto-created ${APP.strings.length} strings`, 'ok');
        APP.recalcStrings();
        APP.renderStringView();
        APP.renderInverterConfig();
        APP.refreshModels();
    },

    undoLastPanel: () => {
        if(APP.currentString.length === 0) return;
        APP.currentString.pop();
        APP.updateCurrentStringInfo();
        APP.renderStringView();
    },

    removeString: (sIdx) => {
        if(sIdx < 0 || sIdx >= APP.strings.length) return;
        const str = APP.strings[sIdx];

        // Unassign from inverter
        if(APP.stringToInverter[sIdx] !== undefined) {
            const inv = APP.inverters[APP.stringToInverter[sIdx]];
            if(inv) inv.strings = inv.strings.filter(s => s !== sIdx);
            delete APP.stringToInverter[sIdx];
        }

        // Free panels
        str.panels.forEach(pIdx => { delete APP.panelToString[pIdx]; });

        // Remove the string
        APP.strings.splice(sIdx, 1);

        // Rebuild panelToString and stringToInverter with new indices
        APP.panelToString = {};
        APP.stringToInverter = {};
        APP.strings.forEach((s, newIdx) => {
            s.panels.forEach(pIdx => { APP.panelToString[pIdx] = newIdx; });
            s.color = STRING_COLORS[newIdx % STRING_COLORS.length];
        });
        APP.inverters.forEach(inv => {
            inv.strings = inv.strings.map(oldIdx => oldIdx > sIdx ? oldIdx - 1 : oldIdx).filter(i => i >= 0 && i < APP.strings.length);
            inv.strings.forEach(si => { APP.stringToInverter[si] = inv.id; });
        });

        APP.activeStringIdx = -1;
        APP.log(`Removed String ${sIdx + 1}`, 'ok');
        APP.recalcStrings();
        APP.renderStringView();
        APP.renderInverterConfig();
        APP.refreshModels();
    },

    clearAllStrings: () => {
        if(APP.strings.length === 0) return;
        APP.strings = [];
        APP.currentString = [];
        APP.activeStringIdx = -1;
        APP.panelToString = {};
        APP.stringToInverter = {};
        APP.inverters.forEach(inv => { inv.strings = []; });
        APP.stringTimeseries = [];
        APP.log("All strings cleared", 'ok');
        APP.renderStringList();
        APP.renderStringView();
        APP.renderInverterConfig();
        APP.refreshModels();
    },

    // ============== REFRESH MODELS (after string/inverter changes) ==============
    refreshModels: () => {
        if(APP.panelTimeseries.length === 0) return; // Analysis hasn't been run yet
        APP.log("Recalculating string-level production (Model B)...");
        APP.generateStringTimeseries();
        APP.runEnergyDispatch();

        // Update summary stats
        const indepTotal = APP.panelTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const stringTotal = APP.stringTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const mismatchLoss = indepTotal > 0 ? ((indepTotal - stringTotal) / indepTotal * 100) : 0;
        document.getElementById('valString').innerText = Math.round(stringTotal).toLocaleString();
        document.getElementById('valMismatch').innerText = mismatchLoss.toFixed(1) + "%";

        // Refresh all dependent views
        APP.renderProdTable();
        APP.renderTimeseries();
        APP.renderInverterView();
        APP.renderBatteryView();
        APP.generateAIAnalysis();
        APP.log(`Model B updated: ${APP.strings.length} strings, ${Math.round(stringTotal).toLocaleString()} kWh, mismatch loss ${mismatchLoss.toFixed(1)}%`, 'ok');
    },

    // ============== RENDERING ==============
    pointInPoly: (pt, poly) => {
        let x = pt.x, y = pt.y, inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            let xi = poly[i].x, yi = poly[i].y;
            let xj = poly[j].x, yj = poly[j].y;
            let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    },

    transform: (x, y) => {
        const rad = APP.rot * Math.PI / 180;
        const rx = x * Math.cos(rad) - y * Math.sin(rad);
        const ry = x * Math.sin(rad) + y * Math.cos(rad);
        return {x:rx, y:ry};
    },

    render: () => {
        APP.rot = parseInt(document.getElementById('rngRot').value);
        document.getElementById('lblRot').innerText = APP.rot + '\u00B0';
        APP.renderMap();
        if(APP.hasShade) APP.sim();
    },

    renderMap: () => {
        const svg = document.getElementById('svgRender');
        const gPanels = document.getElementById('gPanels');
        const gPoints = document.getElementById('gPoints');
        const gLabels = document.getElementById('gLabels');
        const gStrings = document.getElementById('gStrings');
        gPanels.innerHTML=''; gPoints.innerHTML=''; gLabels.innerHTML=''; gStrings.innerHTML='';

        let minX=9e9, maxX=-9e9, minY=9e9, maxY=-9e9;

        APP.geo.forEach((p, idx) => {
            const pts = p.map(pt => APP.transform(pt.x, pt.y));
            pts.forEach(pt => { minX=Math.min(minX,pt.x); maxX=Math.max(maxX,pt.x); minY=Math.min(minY,pt.y); maxY=Math.max(maxY,pt.y); });

            const el = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            el.setAttribute("points", pts.map(pt=>`${pt.x},${pt.y}`).join(" "));

            const stringIdx = APP.panelToString[idx];
            if(stringIdx !== undefined) {
                el.setAttribute("style", `fill:${APP.strings[stringIdx].color}33; stroke:${APP.strings[stringIdx].color};`);
                el.classList.add('strung');
            }
            el.classList.add('poly-panel');
            el.onclick = () => APP.panelClick(idx);
            gPanels.appendChild(el);

            let cx=0, cy=0; pts.forEach(pt=>{cx+=pt.x; cy+=pt.y}); cx/=pts.length; cy/=pts.length;
            const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
            txt.setAttribute("x", cx); txt.setAttribute("y", cy);
            txt.setAttribute("class", "lbl-id");
            txt.textContent = idx + 1;
            gLabels.appendChild(txt);
        });

        APP.rad.forEach(p => {
            const pt = APP.transform(p.x, p.y);
            minX=Math.min(minX,pt.x); maxX=Math.max(maxX,pt.x); minY=Math.min(minY,pt.y); maxY=Math.max(maxY,pt.y);
            const el = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            el.setAttribute("cx", pt.x); el.setAttribute("cy", pt.y);
            el.setAttribute("class", "pt-rad");
            el.id = `pt-${p.id}`;
            const hue = (p.meta.TSRF||0) * 100;
            p.baseColor = `hsl(${hue}, 100%, 50%)`;
            el.setAttribute("fill", p.baseColor);
            gPoints.appendChild(el);
        });

        const w=maxX-minX, h=maxY-minY;
        if(w>0) svg.setAttribute('viewBox', `${minX-w*0.1} ${minY-h*0.1} ${w*1.2} ${h*1.2}`);
    },

    renderStringView: () => {
        const svg = document.getElementById('svgString');
        const gPanels = document.getElementById('gStringPanels');
        const gLines = document.getElementById('gStringLines');
        const gLabels = document.getElementById('gStringLabels');
        gPanels.innerHTML=''; gLines.innerHTML=''; gLabels.innerHTML='';

        let minX=9e9, maxX=-9e9, minY=9e9, maxY=-9e9;

        APP.geo.forEach((p, idx) => {
            const pts = p.map(pt => ({x: pt.x, y: pt.y}));
            pts.forEach(pt => { minX=Math.min(minX,pt.x); maxX=Math.max(maxX,pt.x); minY=Math.min(minY,pt.y); maxY=Math.max(maxY,pt.y); });

            const el = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            el.setAttribute("points", pts.map(pt=>`${pt.x},${pt.y}`).join(" "));

            const stringIdx = APP.panelToString[idx];
            const inCurrentString = APP.currentString.includes(idx);

            if(inCurrentString) {
                el.setAttribute("style", `fill:rgba(167,139,250,0.4); stroke:var(--purple); stroke-width:1.5;`);
            } else if(stringIdx !== undefined) {
                el.setAttribute("style", `fill:${APP.strings[stringIdx].color}33; stroke:${APP.strings[stringIdx].color};`);
            } else {
                el.classList.add('poly-panel');
            }

            el.onclick = () => APP.panelClick(idx);
            gPanels.appendChild(el);

            let cx=0, cy=0; pts.forEach(pt=>{cx+=pt.x; cy+=pt.y}); cx/=pts.length; cy/=pts.length;
            const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
            txt.setAttribute("x", cx); txt.setAttribute("y", cy);
            txt.setAttribute("class", "lbl-id");
            txt.textContent = idx + 1;
            gLabels.appendChild(txt);
        });

        APP.strings.forEach((str, sIdx) => {
            if(str.panels.length < 2) return;
            const centers = str.panels.map(pIdx => {
                const poly = APP.geo[pIdx];
                let cx=0, cy=0;
                poly.forEach(pt => { cx+=pt.x; cy+=pt.y; });
                return { x: cx/poly.length, y: cy/poly.length };
            });

            const pathData = centers.map((c, i) => `${i===0?'M':'L'} ${c.x} ${c.y}`).join(' ');
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", pathData);
            path.setAttribute("class", "string-line");
            path.setAttribute("stroke", str.color);
            gLines.appendChild(path);
        });

        const w=maxX-minX, h=maxY-minY;
        if(w>0) svg.setAttribute('viewBox', `${minX-w*0.1} ${minY-h*0.1} ${w*1.2} ${h*1.2}`);
    },

    sim: () => {
        if(!APP.hasShade) return;
        const day = parseInt(document.getElementById('rngDay').value);
        const int = parseInt(document.getElementById('rngTime').value);
        const idx = (day * 48) + int;

        const d = new Date(2024, 0, day+1);
        document.getElementById('lblDay').innerText = d.toLocaleString('default',{month:'short', day:'numeric'});
        const h = Math.floor(int/2);
        const m = (int%2)*30;
        document.getElementById('lblTime').innerText = `${h}:${m===0?'00':m}`;

        APP.rad.forEach(p => {
            const el = document.getElementById(`pt-${p.id}`);
            if(!el) return;
            const seq = APP.shadeData[p.id];
            if(seq && seq[idx]) {
                const c = seq[idx];
                if(c==='0') { el.setAttribute("fill", "#000"); el.style.opacity=0.8; }
                else if(c==='1') { el.setAttribute("fill", p.baseColor); el.style.opacity=1; }
                else { el.setAttribute("fill", "#334155"); el.style.opacity=0.3; }
            }
        });
    },

    // ============== PRODUCTION TABLE ==============
    renderProdTable: () => {
        const tbody = document.getElementById('tblProd');
        const tfoot = document.getElementById('tblProdFoot');

        let totalIndep = 0, totalStringYield = 0;

        // Compute per-panel string yield: distribute string output proportionally by panel TSRF
        const panelStringYields = new Array(APP.panelStats.length).fill(0);
        APP.strings.forEach((str, sIdx) => {
            if(!APP.stringTimeseries[sIdx]) return;
            const stringAnnualWh = Array.from(APP.stringTimeseries[sIdx]).reduce((a,b) => a+b, 0);
            const stringAnnualKwh = stringAnnualWh / 2000;

            // Distribute proportionally by panel TSRF within string
            let totalTsrf = 0;
            str.panels.forEach(pIdx => { totalTsrf += (APP.panelStats[pIdx]?.tsrf || 0.5); });
            str.panels.forEach(pIdx => {
                const panelTsrf = APP.panelStats[pIdx]?.tsrf || 0.5;
                panelStringYields[pIdx] = stringAnnualKwh * (panelTsrf / (totalTsrf || 1));
            });
        });

        tbody.innerHTML = APP.panelStats.map((p, idx) => {
            const stringIdx = APP.panelToString[p.id - 1];
            const stringName = stringIdx !== undefined ? `S${stringIdx + 1}` : '-';
            const evSAV = APP.eagleViewProduction.panelSAV[idx];
            const evSAVStr = evSAV !== undefined ? (evSAV * 100).toFixed(1) + '%' : '-';

            const indepYield = p.yield;
            const strYield = panelStringYields[idx] || 0;
            const mismatch = indepYield > 0 && strYield > 0 ? ((indepYield - strYield) / indepYield * 100) : 0;

            totalIndep += indepYield;
            totalStringYield += strYield;

            const status = p.tsrf < 0.5 ? '<span style="color:var(--err);">Poor</span>'
                : p.tsrf < 0.7 ? '<span style="color:var(--warn);">Low</span>'
                : '<span style="color:var(--success);">OK</span>';

            return `<tr>
                <td>P${p.id}</td>
                <td>${stringName}</td>
                <td>${(p.irr/1000).toFixed(0)}</td>
                <td>${(p.tsrf*100).toFixed(1)}%</td>
                <td>${Math.round(indepYield)}</td>
                <td>${strYield > 0 ? Math.round(strYield) : '-'}</td>
                <td>${strYield > 0 ? mismatch.toFixed(1) + '%' : '-'}</td>
                <td>${evSAVStr}</td>
                <td>${status}</td>
            </tr>`;
        }).join('');

        // Footer totals
        const evTotal = APP.eagleViewProduction.annual;
        tfoot.style.display = '';
        tfoot.innerHTML = `<tr>
            <td colspan="4" style="text-align:right;">TOTALS:</td>
            <td>${Math.round(totalIndep).toLocaleString()}</td>
            <td>${totalStringYield > 0 ? Math.round(totalStringYield).toLocaleString() : '-'}</td>
            <td>${totalIndep > 0 && totalStringYield > 0 ? ((totalIndep - totalStringYield)/totalIndep*100).toFixed(1) + '%' : '-'}</td>
            <td colspan="2">${evTotal > 0 ? 'EV: ' + Math.round(evTotal).toLocaleString() + ' kWh' : ''}</td>
        </tr>`;
    },

    // ============== TIMESERIES NAVIGATION ==============
    tsNav: (dir) => {
        const period = APP.tsPeriod;
        if(period === 'day') APP.tsDay = Math.max(0, Math.min(364, APP.tsDay + dir));
        else if(period === 'week') APP.tsDay = Math.max(0, Math.min(364, APP.tsDay + dir * 7));
        else if(period === 'month') {
            const d = new Date(2024, 0, APP.tsDay + 1);
            d.setMonth(d.getMonth() + dir);
            APP.tsDay = Math.max(0, Math.min(364, Math.floor((d - new Date(2024,0,1)) / 86400000)));
        }
        document.getElementById('tsDateSlider').value = APP.tsDay;
        APP.renderTimeseries();
    },

    // Helper: get timeseries data for a source selector
    _getTsData: (model, sel, dayStart, dayEnd) => {
        const data48 = new Array(48).fill(0);
        const days = dayEnd - dayStart;
        if(model === 'independent' || (model === 'string' && APP.stringTimeseries.length === 0)) {
            if(sel === 'system') {
                for(let h = 0; h < 48; h++) { let s=0; APP.panelTimeseries.forEach(sr => { for(let d=dayStart; d<dayEnd; d++) s += sr[d*48+h]; }); data48[h] = s / days; }
            } else if(sel.startsWith('string-')) {
                const sIdx = parseInt(sel.split('-')[1]);
                const panels = APP.strings[sIdx]?.panels || [];
                for(let h = 0; h < 48; h++) { let s=0; panels.forEach(pIdx => { const sr = APP.panelTimeseries[pIdx]; if(sr) for(let d=dayStart; d<dayEnd; d++) s += sr[d*48+h]; }); data48[h] = s / days; }
            } else if(sel.startsWith('panel-')) {
                const pIdx = parseInt(sel.split('-')[1]); const sr = APP.panelTimeseries[pIdx];
                if(sr) for(let h = 0; h < 48; h++) { let s=0; for(let d=dayStart; d<dayEnd; d++) s += sr[d*48+h]; data48[h] = s / days; }
            }
        } else {
            if(sel === 'system') {
                for(let h = 0; h < 48; h++) { let s=0; APP.stringTimeseries.forEach(sr => { for(let d=dayStart; d<dayEnd; d++) s += sr[d*48+h]; }); data48[h] = s / days; }
            } else if(sel.startsWith('string-')) {
                const sIdx = parseInt(sel.split('-')[1]); const sr = APP.stringTimeseries[sIdx];
                if(sr) for(let h = 0; h < 48; h++) { let s=0; for(let d=dayStart; d<dayEnd; d++) s += sr[d*48+h]; data48[h] = s / days; }
            } else if(sel.startsWith('panel-')) {
                const pIdx = parseInt(sel.split('-')[1]); const sr = APP.panelTimeseries[pIdx];
                if(sr) for(let h = 0; h < 48; h++) { let s=0; for(let d=dayStart; d<dayEnd; d++) s += sr[d*48+h]; data48[h] = s / days; }
            }
        }
        return data48;
    },

    // ============== 30-MIN TIMESERIES CHART ==============
    renderTimeseries: () => {
        const container = document.getElementById('tsChart');
        const select = document.getElementById('tsSelect');
        const model = document.getElementById('tsModel').value;
        const period = APP.tsPeriod;

        // Update period button styles
        ['Day','Week','Month','Year'].forEach(p => {
            const btn = document.getElementById('tsPeriod' + p);
            if(btn) { btn.style.background = p.toLowerCase() === period ? 'var(--accent)' : '#475569'; btn.style.color = p.toLowerCase() === period ? '#0f172a' : 'white'; }
        });

        // Update dropdown options
        const prevVal = select.value;
        select.innerHTML = '<option value="system">System Total</option>';
        APP.strings.forEach((s, i) => { select.innerHTML += `<option value="string-${i}">String ${i+1} (${s.panels.length}p)</option>`; });
        APP.panelStats.forEach((p, i) => { select.innerHTML += `<option value="panel-${i}">Panel ${p.id}</option>`; });
        if(select.querySelector(`option[value="${prevVal}"]`)) select.value = prevVal;

        if(!APP.panelTimeseries.length) return;

        const sel = select.value;

        // Compute date range
        let dayStart, dayEnd, dateLabel;
        const baseDate = new Date(2024, 0, APP.tsDay + 1);
        if(period === 'day') {
            dayStart = APP.tsDay; dayEnd = APP.tsDay + 1;
            dateLabel = baseDate.toLocaleDateString('default', {month:'short', day:'numeric', weekday:'short'});
        } else if(period === 'week') {
            dayStart = Math.max(0, APP.tsDay - (baseDate.getDay())); dayEnd = Math.min(365, dayStart + 7);
            const ws = new Date(2024,0,dayStart+1); const we = new Date(2024,0,dayEnd);
            dateLabel = `${ws.toLocaleDateString('default',{month:'short',day:'numeric'})} – ${we.toLocaleDateString('default',{month:'short',day:'numeric'})}`;
        } else if(period === 'month') {
            const m = baseDate.getMonth();
            dayStart = Math.floor((new Date(2024, m, 1) - new Date(2024,0,1)) / 86400000);
            dayEnd = Math.min(365, Math.floor((new Date(2024, m+1, 1) - new Date(2024,0,1)) / 86400000));
            dateLabel = baseDate.toLocaleDateString('default', {month:'long', year:'numeric'});
        } else {
            dayStart = 0; dayEnd = 365;
            dateLabel = 'Full Year 2024';
        }
        document.getElementById('tsDateLabel').innerText = dateLabel;
        document.getElementById('tsDateSlider').value = APP.tsDay;

        // Get data for selected model
        const data = APP._getTsData(model, sel, dayStart, dayEnd);
        // Also get comparison data if toggles are on
        const showA = document.getElementById('tsShowA').checked;
        const showB = document.getElementById('tsShowB').checked && APP.stringTimeseries.length > 0;
        const showC = document.getElementById('tsShowC').checked;
        const dataA = showA ? APP._getTsData('independent', sel, dayStart, dayEnd) : null;
        const dataB = showB ? APP._getTsData('string', sel, dayStart, dayEnd) : null;

        // AC limit
        let acLimit = 0;
        if(sel === 'system') {
            APP.inverters.forEach(inv => { acLimit += (inv.spec || EQUIPMENT.inverters[inv.typeKey]).acPower; });
            if(acLimit === 0 && APP.inverter) acLimit = APP.inverter.acPower;
            acLimit *= APP.clippingThreshold;
        }

        const allVals = [...data];
        if(dataA) allVals.push(...dataA);
        if(dataB) allVals.push(...dataB);
        // Include consumption peak in scale so line doesn't go off-chart
        let loadPeakW = 0;
        if(APP.homeConsumption.enabled && APP.homeConsumption.profile) {
            for(let t = dayStart * 48; t < dayEnd * 48 && t < 17520; t++) loadPeakW = Math.max(loadPeakW, APP.homeConsumption.profile[t]);
        }
        const maxVal = Math.max(...allVals, acLimit || 1, loadPeakW, 1);

        const chartH = 260; const chartW = container.clientWidth - 65;
        const barW = Math.max(2, Math.floor(chartW / 48) - 1);

        let html = '';
        // Y-axis
        for(let i = 0; i <= 4; i++) {
            const val = (maxVal / 4) * (4 - i);
            const y = (i / 4) * chartH;
            html += `<div style="position:absolute; left:0; top:${y}px; width:45px; text-align:right; font-size:8px; color:#64748b; transform:translateY(-5px);">${(val/1000).toFixed(1)} kW</div>`;
            html += `<div style="position:absolute; left:50px; right:0; top:${y}px; height:1px; background:rgba(255,255,255,0.05);"></div>`;
        }

        // AC limit line
        if(acLimit > 0 && sel === 'system') {
            const limitY = chartH - (acLimit / maxVal) * chartH;
            html += `<div style="position:absolute; left:50px; right:0; top:${limitY}px; border-top:2px dashed var(--err); z-index:5;"></div>`;
            html += `<div style="position:absolute; right:4px; top:${limitY - 14}px; font-size:8px; color:var(--err); z-index:6;">Threshold: ${(acLimit/1000).toFixed(1)}kW</div>`;
        }

        // Bars — draw Model A behind, Model B on top (or just selected model)
        const drawBars = (d, color, opacity, offsetX) => {
            if(!d) return '';
            let s = '';
            d.forEach((v, i) => {
                const h = (v / maxVal) * chartH;
                const isClip = acLimit > 0 && v > acLimit;
                const bg = isClip ? 'var(--warn)' : color;
                s += `<div style="position:absolute; bottom:0; left:${50 + i * (barW + 1) + offsetX}px; width:${barW}px; height:${h}px; background:${bg}; opacity:${opacity}; border-radius:1px 1px 0 0;" title="${Math.floor(i/2)}:${(i%2)*30||'00'} — ${(v/1000).toFixed(2)} kW"></div>`;
            });
            return s;
        };

        if(showA && showB) {
            html += drawBars(dataA, 'var(--accent)', '0.4', 0);
            html += drawBars(dataB, 'var(--purple)', '0.85', 0);
        } else if(showA) {
            html += drawBars(dataA, 'var(--accent)', '0.9', 0);
        } else if(showB) {
            html += drawBars(dataB, 'var(--purple)', '0.9', 0);
        } else {
            html += drawBars(data, 'var(--accent)', '0.9', 0);
        }

        // Home consumption overlay (SVG polyline — works all periods)
        if(APP.homeConsumption.enabled && APP.homeConsumption.profile) {
            const profile = APP.homeConsumption.profile;
            // Build averaged 48-slot consumption data for the date range
            const days = dayEnd - dayStart;
            const loadData = new Float32Array(48);
            for(let h = 0; h < 48; h++) {
                let s = 0;
                for(let d = dayStart; d < dayEnd; d++) { const t = d * 48 + h; if(t < 17520) s += profile[t]; }
                loadData[h] = s / days;
            }
            let loadPath = '';
            for(let i = 0; i < 48; i++) {
                const y = chartH - (loadData[i] / maxVal) * chartH;
                const x = 50 + i * (barW + 1) + barW / 2;
                loadPath += (i === 0 ? 'M' : ' L') + ` ${x.toFixed(1)} ${y.toFixed(1)}`;
            }
            html += `<svg style="position:absolute; top:0; left:0; width:100%; height:${chartH}px; pointer-events:none; z-index:6;">
                <path d="${loadPath}" fill="none" stroke="var(--err)" stroke-width="1.5" stroke-dasharray="4,2" opacity="0.8"/>
            </svg>`;
            html += `<div style="position:absolute; right:4px; top:4px; font-size:8px; color:var(--err); opacity:0.8; z-index:7;">--- Home Load</div>`;
        }

        // X-axis labels (adapted per period)
        html += '<div style="position:absolute; bottom:-25px; left:50px; right:0; display:flex; justify-content:space-between; font-size:8px; color:#64748b;">';
        if(period === 'day') {
            for(let h = 0; h <= 24; h += 2) html += `<span>${h}:00</span>`;
        } else if(period === 'week') {
            const dayNames = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
            const ws = new Date(2024, 0, dayStart + 1);
            for(let d = 0; d < 7; d++) { const dt = new Date(ws); dt.setDate(dt.getDate()+d); html += `<span>${dayNames[dt.getDay() === 0 ? 6 : dt.getDay()-1]}</span>`; }
        } else if(period === 'month') {
            for(let d = 1; d <= 31; d += 5) html += `<span>${d}</span>`;
        } else {
            const mNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            mNames.forEach(m => html += `<span>${m}</span>`);
        }
        html += '</div>';

        container.innerHTML = html;

        // Render split battery chart below production
        APP.renderBatteryTimeseries(sel, dayStart, dayEnd, period, barW);

        // EagleView monthly comparison bar (if showC and year/month view)
        // Stats dashboard
        const peakA = dataA ? Math.max(...dataA) : 0;
        const peakB = dataB ? Math.max(...dataB) : 0;
        const sumA = dataA ? dataA.reduce((a,b) => a+b, 0) : 0;
        const sumB = dataB ? dataB.reduce((a,b) => a+b, 0) : 0;
        const dailyKwhA = sumA / 2000; // W * 0.5h / 1000
        const dailyKwhB = sumB / 2000;
        const daysInRange = dayEnd - dayStart;

        // Annualized production estimates
        const annualA = APP.panelTimeseries.reduce((s, sr) => s + Array.from(sr).reduce((a,b) => a+b, 0) / 2000, 0);
        const annualB = APP.stringTimeseries.reduce((s, sr) => s + Array.from(sr).reduce((a,b) => a+b, 0) / 2000, 0);
        const annualC = APP.eagleViewProduction.annual;
        const mismatch = annualA > 0 ? ((annualA - annualB) / annualA * 100) : 0;

        // Period production
        const periodKwhA = dailyKwhA * daysInRange;
        const periodKwhB = dailyKwhB * daysInRange;
        const periodLabel = period === 'year' ? 'Annual' : period === 'month' ? 'Monthly' : period === 'week' ? 'Weekly' : 'Daily';

        let statsHtml = `
        <div style="margin-bottom:10px; font-size:10px; font-weight:600; color:#94a3b8; text-transform:uppercase;">${periodLabel} Production Comparison — ${dateLabel}</div>
        <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:8px;">
            ${showA ? `<div class="stat-item" style="border-color:var(--accent);"><span class="stat-val-sm" style="color:var(--accent);">${periodKwhA.toFixed(1)} kWh</span><span class="stat-name">Model A (Independent)</span></div>` : ''}
            ${showB ? `<div class="stat-item" style="border-color:var(--purple);"><span class="stat-val-sm" style="color:var(--purple);">${periodKwhB.toFixed(1)} kWh</span><span class="stat-name">Model B (String)</span></div>` : ''}
            ${showC && annualC > 0 ? `<div class="stat-item" style="border-color:var(--success);"><span class="stat-val-sm" style="color:var(--success);">${period === 'year' ? Math.round(annualC).toLocaleString() : (annualC / 365 * daysInRange).toFixed(1)} kWh</span><span class="stat-name">Model C (EagleView)</span></div>` : ''}
        </div>
        <div style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:8px;">
            <div class="stat-item"><span class="stat-val-sm">${(peakA/1000).toFixed(2)} kW</span><span class="stat-name">Peak A</span></div>
            <div class="stat-item"><span class="stat-val-sm">${(peakB/1000).toFixed(2)} kW</span><span class="stat-name">Peak B</span></div>
            <div class="stat-item"><span class="stat-val-sm">${mismatch.toFixed(1)}%</span><span class="stat-name">Mismatch Loss</span></div>
            <div class="stat-item"><span class="stat-val-sm">${APP.clippingLoss.toFixed(1)}%</span><span class="stat-name">Clipping Loss</span></div>
        </div>
        <div style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px;">
            <div class="stat-item"><span class="stat-val-sm">${Math.round(annualA).toLocaleString()}</span><span class="stat-name">Annual A (kWh)</span></div>
            <div class="stat-item"><span class="stat-val-sm">${Math.round(annualB).toLocaleString()}</span><span class="stat-name">Annual B (kWh)</span></div>
            <div class="stat-item"><span class="stat-val-sm">${annualC > 0 ? Math.round(annualC).toLocaleString() : 'N/A'}</span><span class="stat-name">Annual C (kWh)</span></div>
            <div class="stat-item"><span class="stat-val-sm">${(APP.geo.length * APP.panel.watts / 1000).toFixed(1)} kW</span><span class="stat-name">DC Capacity</span></div>
        </div>`;
        document.getElementById('tsStats').innerHTML = statsHtml;

        // String info panel
        let stringInfoHtml = '';
        if(sel.startsWith('string-')) {
            const sIdx = parseInt(sel.split('-')[1]);
            const str = APP.strings[sIdx];
            if(str) {
                const elec = str.electrical || APP.calculateStringElectrical(str.panels);
                const invIdx = APP.stringToInverter[sIdx];
                const invName = invIdx !== undefined ? APP.inverters[invIdx].name + ': ' + (APP.inverters[invIdx].spec || EQUIPMENT.inverters[APP.inverters[invIdx].typeKey]).name : 'Unassigned';
                stringInfoHtml = `
                <div class="card" style="border-color:${str.color};">
                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                        <div style="width:14px; height:14px; border-radius:3px; background:${str.color};"></div>
                        <span style="font-weight:600; color:${str.color};">String ${sIdx+1}</span>
                        <span style="font-size:10px; color:#94a3b8;">→ ${invName}</span>
                    </div>
                    <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:6px; font-size:10px;">
                        <div class="inv-stat">Panels: ${str.panels.length} (${str.panels.map(p => 'P' + (p+1)).join(', ')})</div>
                        <div class="inv-stat">Voc (cold): ${elec.vocCold.toFixed(1)}V</div>
                        <div class="inv-stat">Vmp: ${elec.vmp.toFixed(1)}V</div>
                        <div class="inv-stat">Power: ${(elec.power/1000).toFixed(2)} kW</div>
                        <div class="inv-stat">Isc: ${elec.isc.toFixed(2)}A</div>
                        <div class="inv-stat">Imp: ${elec.imp.toFixed(2)}A</div>
                    </div>
                    ${elec.warning ? `<div style="margin-top:6px; color:var(--warn); font-size:10px;">⚠ ${elec.warning}</div>` : ''}
                </div>`;
            }
        }
        document.getElementById('tsStringInfo').innerHTML = stringInfoHtml;
    },

    // ============== BATTERY TIMESERIES (split chart below production) ==============
    renderBatteryTimeseries: (sel, dayStart, dayEnd, period, barW) => {
        const battContainer = document.getElementById('tsBattChart');
        if(!battContainer) return;
        const hasBattery = APP.batteryState.some(b => b !== null);
        const showSoC = document.getElementById('tsShowSoC')?.checked;
        const showBattPower = document.getElementById('tsShowBattPower')?.checked;

        if(!hasBattery || (!showSoC && !showBattPower) || sel !== 'system') {
            battContainer.style.display = 'none';
            return;
        }
        battContainer.style.display = '';

        const chartH = 120;
        const chartW = battContainer.clientWidth - 65;
        const totalCapWh = APP.batteryState.filter(b => b).reduce((s, b) => s + b.config.totalCapacityWh, 0);
        const days = dayEnd - dayStart;

        // Build 48-slot averaged battery data
        const socData = new Float32Array(48);
        const chargeData = new Float32Array(48);
        const dischData = new Float32Array(48);
        for(let h = 0; h < 48; h++) {
            let socSum = 0, chgSum = 0, disSum = 0, count = 0;
            for(let d = dayStart; d < dayEnd; d++) {
                const t = d * 48 + h;
                if(t >= 17520) break;
                APP.batteryState.forEach(b => {
                    if(!b) return;
                    socSum += b.socWh[t];
                    chgSum += b.chargeW[t] || 0;
                    disSum += b.dischargeW[t] || 0;
                    count++;
                });
            }
            const nBatt = APP.batteryState.filter(b => b).length || 1;
            socData[h] = count > 0 ? socSum / (count / nBatt) : 0;
            chargeData[h] = count > 0 ? chgSum / (count / nBatt) : 0;
            dischData[h] = count > 0 ? disSum / (count / nBatt) : 0;
        }

        const maxPower = Math.max(Math.max(...chargeData), Math.max(...dischData), 1);
        const midY = chartH / 2; // center line: charge goes up, discharge goes down

        let bhtml = '';

        // Center baseline
        bhtml += `<div style="position:absolute; left:50px; right:0; top:${midY}px; height:1px; background:rgba(255,255,255,0.15); z-index:2;"></div>`;

        // Left Y-axis labels (power)
        const pwrLabels = [maxPower, maxPower/2, 0, -maxPower/2, -maxPower];
        for(let i = 0; i < 5; i++) {
            const y = (i / 4) * chartH;
            const val = pwrLabels[i];
            bhtml += `<div style="position:absolute; left:0; top:${y}px; width:45px; text-align:right; font-size:7px; color:#64748b; transform:translateY(-4px);">${val >= 0 ? '+' : ''}${(val/1000).toFixed(1)}kW</div>`;
            if(i > 0 && i < 4) bhtml += `<div style="position:absolute; left:50px; right:30px; top:${y}px; height:1px; background:rgba(255,255,255,0.04);"></div>`;
        }

        // Charge/discharge bars (bidirectional from center)
        if(showBattPower) {
            for(let i = 0; i < 48; i++) {
                const x = 50 + i * (barW + 1);
                if(chargeData[i] > 0) {
                    const h = (chargeData[i] / maxPower) * midY;
                    bhtml += `<div style="position:absolute; left:${x}px; top:${midY - h}px; width:${barW}px; height:${h}px; background:#22d3ee; opacity:0.8; border-radius:1px 1px 0 0;" title="${Math.floor(i/2)}:${(i%2)*30||'00'} Charge: ${(chargeData[i]/1000).toFixed(2)} kW"></div>`;
                }
                if(dischData[i] > 0) {
                    const h = (dischData[i] / maxPower) * midY;
                    bhtml += `<div style="position:absolute; left:${x}px; top:${midY}px; width:${barW}px; height:${h}px; background:#f472b6; opacity:0.8; border-radius:0 0 1px 1px;" title="${Math.floor(i/2)}:${(i%2)*30||'00'} Discharge: ${(dischData[i]/1000).toFixed(2)} kW"></div>`;
                }
            }
            bhtml += `<div style="position:absolute; left:52px; top:2px; font-size:7px; z-index:7;"><span style="color:#22d3ee;">▲ Charge</span> <span style="color:#f472b6;">▼ Discharge</span></div>`;
        }

        // SoC overlay (orange area, right Y-axis 0-100%)
        if(showSoC && totalCapWh > 0) {
            let socPath = `M 50 ${chartH}`;
            for(let i = 0; i < 48; i++) {
                const socPct = socData[i] / totalCapWh;
                const y = chartH - (socPct * chartH);
                const x = 50 + i * (barW + 1) + barW / 2;
                socPath += ` L ${x.toFixed(1)} ${y.toFixed(1)}`;
            }
            const lastX = 50 + 47 * (barW + 1) + barW / 2;
            socPath += ` L ${lastX} ${chartH} Z`;
            bhtml += `<svg style="position:absolute; top:0; left:0; width:100%; height:${chartH}px; pointer-events:none; z-index:1;">
                <path d="${socPath}" fill="var(--orange)" opacity="0.15"/>
            </svg>`;

            // Right Y-axis (SoC %)
            for(let i = 0; i <= 4; i++) {
                const pct = (4 - i) * 25;
                const y = (i / 4) * chartH;
                bhtml += `<div style="position:absolute; right:0; top:${y}px; width:28px; text-align:left; font-size:7px; color:var(--orange); transform:translateY(-4px);">${pct}%</div>`;
            }

            // SoC labels at key points
            for(let i = 0; i < 48; i += 12) {
                const socPct = (socData[i] / totalCapWh * 100);
                const y = chartH - (socData[i] / totalCapWh * chartH);
                const x = 50 + i * (barW + 1) + barW / 2;
                bhtml += `<div style="position:absolute; left:${x - 10}px; top:${y - 12}px; font-size:7px; color:var(--orange); font-weight:bold; pointer-events:none; z-index:7;">${socPct.toFixed(0)}%</div>`;
            }
            bhtml += `<div style="position:absolute; right:4px; top:2px; font-size:7px; color:var(--orange); opacity:0.8; z-index:7;">SoC (${(totalCapWh/1000).toFixed(1)} kWh)</div>`;
        }

        // X-axis time labels
        bhtml += '<div style="position:absolute; bottom:-18px; left:50px; right:30px; display:flex; justify-content:space-between; font-size:7px; color:#64748b;">';
        if(period === 'day') {
            for(let h = 0; h <= 24; h += 4) bhtml += `<span>${h}:00</span>`;
        } else {
            for(let h = 0; h <= 24; h += 6) bhtml += `<span>${h}h</span>`;
        }
        bhtml += '</div>';

        battContainer.innerHTML = bhtml;
    },

    // ============== INVERTER VIEW ==============
    setInvChartMode: (mode) => {
        APP.invChartMode = mode;
        APP.invSelectedDay = -1;
        APP.renderInverterView();
    },

    selectInvDay: (invIdx, day) => {
        APP.invSelectedDay = day;
        APP.renderInverterView();
    },

    // ============== BATTERY VIEW ==============
    renderBatteryView: () => {
        const container = document.getElementById('batteryContent');
        const hasBattery = APP.batteryState.some(b => b !== null);
        const hasConsumption = APP.homeConsumption.enabled;

        if(!hasBattery && !hasConsumption) {
            container.innerHTML = '<div style="color:#64748b; text-align:center; padding-top:50px;">Configure ESS (battery) or home consumption to see energy dispatch simulation</div>';
            return;
        }

        if(!APP.dispatchTimeseries || APP.dispatchTimeseries.length === 0) {
            container.innerHTML = '<div style="color:#64748b; text-align:center; padding-top:50px;">Run analysis to generate battery simulation</div>';
            return;
        }

        const eb = APP.energyBalance;
        let html = '';

        // Energy Balance Summary Cards
        html += `<h3 style="margin:0 0 12px 0; font-size:14px; color:var(--accent);">Energy Balance</h3>`;
        html += `<div style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:16px;">
            <div style="text-align:center; padding:10px; background:rgba(56,189,248,0.1); border:1px solid var(--accent); border-radius:6px;">
                <div style="font-size:18px; font-weight:700; color:var(--accent);">${Math.round(eb.totalProduction).toLocaleString()}</div>
                <div style="font-size:9px; color:#94a3b8;">Total Production kWh</div>
            </div>
            <div style="text-align:center; padding:10px; background:rgba(52,211,153,0.1); border:1px solid var(--success); border-radius:6px;">
                <div style="font-size:18px; font-weight:700; color:var(--success);">${Math.round(eb.selfConsumed).toLocaleString()}</div>
                <div style="font-size:9px; color:#94a3b8;">Self-Consumed kWh</div>
            </div>
            <div style="text-align:center; padding:10px; background:rgba(251,146,60,0.1); border:1px solid var(--orange); border-radius:6px;">
                <div style="font-size:18px; font-weight:700; color:var(--orange);">${Math.round(eb.gridExport).toLocaleString()}</div>
                <div style="font-size:9px; color:#94a3b8;">Grid Export kWh</div>
            </div>
            <div style="text-align:center; padding:10px; background:rgba(239,68,68,0.1); border:1px solid var(--err); border-radius:6px;">
                <div style="font-size:18px; font-weight:700; color:var(--err);">${Math.round(eb.gridImport).toLocaleString()}</div>
                <div style="font-size:9px; color:#94a3b8;">Grid Import kWh</div>
            </div>
        </div>`;

        // Battery stats row
        if(hasBattery) {
            const selfPct = eb.totalProduction > 0 ? (eb.selfConsumed / eb.totalProduction * 100) : 0;
            const totalCapWh = APP.batteryState.filter(b=>b).reduce((a,b) => a + b.config.totalCapacityWh, 0);
            const cycles = totalCapWh > 0 ? (eb.batteryCharged * 1000 / totalCapWh) : 0;

            html += `<div style="display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-bottom:16px;">
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--success);">${selfPct.toFixed(1)}%</div>
                    <div style="font-size:9px; color:#94a3b8;">Self-Consumption</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--orange);">${Math.round(eb.batteryCharged).toLocaleString()}</div>
                    <div style="font-size:9px; color:#94a3b8;">Battery Charged kWh</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--purple);">${Math.round(eb.batteryDischarged).toLocaleString()}</div>
                    <div style="font-size:9px; color:#94a3b8;">Battery Discharged kWh</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--warn);">${cycles.toFixed(0)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Annual Cycles</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--err);">${Math.round(eb.batteryLosses).toLocaleString()}</div>
                    <div style="font-size:9px; color:#94a3b8;">Round-Trip Loss kWh</div>
                </div>
            </div>`;

            // Loss breakdown
            const totalLost = eb.clipped + eb.curtailed;
            html += `<div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:16px;">
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:14px; font-weight:700; color:var(--err);">${eb.clipped.toFixed(1)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Inverter Clipping kWh</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:14px; font-weight:700; color:var(--warn);">${eb.curtailed.toFixed(1)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Export Curtailed kWh</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:14px; font-weight:700; color:var(--text);">${totalLost.toFixed(1)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Total Lost kWh</div>
                </div>
            </div>`;
        }

        // Per-inverter battery SoC charts
        if(hasBattery) {
            html += `<h3 style="margin:16px 0 12px 0; font-size:14px; color:var(--orange);">Battery State of Charge (Daily View)</h3>`;
            html += `<div style="display:flex; gap:6px; margin-bottom:12px;">
                <button class="btn-sm" onclick="APP.batteryChartMode='daily';APP.renderBatteryView()" style="background:${APP.batteryChartMode==='daily'?'var(--accent)':'#475569'}; color:${APP.batteryChartMode==='daily'?'#0f172a':'white'};">Daily</button>
                <button class="btn-sm" onclick="APP.batteryChartMode='weekly';APP.renderBatteryView()" style="background:${APP.batteryChartMode==='weekly'?'var(--accent)':'#475569'}; color:${APP.batteryChartMode==='weekly'?'#0f172a':'white'};">Weekly</button>
                <button class="btn-sm" onclick="APP.batteryChartMode='monthly';APP.renderBatteryView()" style="background:${APP.batteryChartMode==='monthly'?'var(--accent)':'#475569'}; color:${APP.batteryChartMode==='monthly'?'#0f172a':'white'};">Monthly</button>
            </div>`;

            APP.batteryState.forEach((bState, invIdx) => {
                if(!bState) return;
                const inv = APP.inverters[invIdx];
                const bCfg = bState.config;
                const capKwh = bCfg.totalCapacityWh / 1000;

                html += `<div style="margin-bottom:16px; padding:12px; background:rgba(0,0,0,0.3); border-radius:8px; border:1px solid #334155;">`;
                html += `<div style="font-weight:600; margin-bottom:8px;">${inv.name} — ${capKwh.toFixed(1)} kWh Battery</div>`;

                // Build SoC chart data
                const chartH = 100;
                const mode = APP.batteryChartMode;
                let bars = [];

                if(mode === 'daily') {
                    for(let d = 0; d < 365; d++) {
                        let maxSoC = 0, minSoC = bCfg.totalCapacityWh;
                        for(let h = 0; h < 48; h++) {
                            const soc = bState.socWh[d * 48 + h];
                            maxSoC = Math.max(maxSoC, soc);
                            minSoC = Math.min(minSoC, soc);
                        }
                        bars.push({ maxPct: maxSoC / bCfg.totalCapacityWh * 100, minPct: minSoC / bCfg.totalCapacityWh * 100 });
                    }
                } else if(mode === 'weekly') {
                    for(let w = 0; w < 52; w++) {
                        const ds = w * 7; const de = Math.min(365, ds + 7);
                        let maxSoC = 0, minSoC = bCfg.totalCapacityWh;
                        for(let d = ds; d < de; d++) {
                            for(let h = 0; h < 48; h++) {
                                const soc = bState.socWh[d * 48 + h];
                                maxSoC = Math.max(maxSoC, soc);
                                minSoC = Math.min(minSoC, soc);
                            }
                        }
                        bars.push({ maxPct: maxSoC / bCfg.totalCapacityWh * 100, minPct: minSoC / bCfg.totalCapacityWh * 100 });
                    }
                } else {
                    for(let m = 0; m < 12; m++) {
                        const ds = Math.floor((new Date(2024, m, 1) - new Date(2024,0,1)) / 86400000);
                        const de = Math.min(365, Math.floor((new Date(2024, m+1, 1) - new Date(2024,0,1)) / 86400000));
                        let maxSoC = 0, minSoC = bCfg.totalCapacityWh;
                        for(let d = ds; d < de; d++) {
                            for(let h = 0; h < 48; h++) {
                                const soc = bState.socWh[d * 48 + h];
                                maxSoC = Math.max(maxSoC, soc);
                                minSoC = Math.min(minSoC, soc);
                            }
                        }
                        bars.push({ maxPct: maxSoC / bCfg.totalCapacityWh * 100, minPct: minSoC / bCfg.totalCapacityWh * 100 });
                    }
                }

                // Render SoC range chart
                let chartHtml = `<div style="position:relative; height:${chartH + 20}px; background:rgba(0,0,0,0.3); border-radius:4px; padding-left:30px; padding-bottom:15px; overflow:hidden;">`;
                // Y axis
                for(let i = 0; i <= 4; i++) {
                    const pct = i * 25;
                    const y = chartH - (pct / 100) * chartH;
                    chartHtml += `<div style="position:absolute; left:0; top:${y}px; width:26px; text-align:right; font-size:7px; color:#64748b; transform:translateY(-4px);">${pct}%</div>`;
                    chartHtml += `<div style="position:absolute; left:30px; right:0; top:${y}px; height:1px; background:rgba(255,255,255,0.04);"></div>`;
                }
                // Bars (range from min to max SoC)
                bars.forEach((b, i) => {
                    const bw = Math.max(1, Math.floor(70 / bars.length));
                    const left = 30 + (i / bars.length) * 70 + '%';
                    const minH = (b.minPct / 100) * chartH;
                    const maxH = (b.maxPct / 100) * chartH;
                    chartHtml += `<div style="position:absolute; bottom:15px; left:calc(30px + ${(i / bars.length * 100).toFixed(1)}%); width:${(100 / bars.length * 0.8).toFixed(1)}%; height:${maxH}px; background:rgba(251,146,60,0.2); border-radius:1px 1px 0 0;"></div>`;
                    chartHtml += `<div style="position:absolute; bottom:${15 + minH}px; left:calc(30px + ${(i / bars.length * 100).toFixed(1)}%); width:${(100 / bars.length * 0.8).toFixed(1)}%; height:${maxH - minH}px; background:var(--orange); opacity:0.6; border-radius:1px;"></div>`;
                });
                chartHtml += '</div>';
                html += chartHtml;

                // Summary for this battery
                const avgSoC = Array.from(bState.socWh).reduce((a,b) => a+b, 0) / 17520;
                const chgTotal = Array.from(bState.chargeW).reduce((a,b) => a+b, 0) * 0.5 / 1000;
                const dischTotal = Array.from(bState.dischargeW).reduce((a,b) => a+b, 0) * 0.5 / 1000;
                html += `<div style="display:flex; gap:12px; margin-top:6px; font-size:10px; color:#94a3b8;">
                    <span>Avg SoC: <strong style="color:var(--orange);">${(avgSoC / bCfg.totalCapacityWh * 100).toFixed(1)}%</strong></span>
                    <span>Charged: <strong style="color:var(--success);">${Math.round(chgTotal)} kWh</strong></span>
                    <span>Discharged: <strong style="color:var(--purple);">${Math.round(dischTotal)} kWh</strong></span>
                    <span>DC Rate: <strong>${(bCfg.totalDcChargeW/1000).toFixed(0)} kW</strong></span>
                </div>`;
                html += '</div>';
            });
        }

        // ─── Steps 4A-F: Battery Analytics Panels (from APP.batteryAnalytics) ───
        const ba = APP.batteryAnalytics;
        if(hasBattery && ba) {

            // 4A. Monthly Battery Performance Table
            html += `<h3 style="margin:16px 0 12px 0; font-size:14px; color:var(--accent);">Monthly Battery Performance</h3>`;
            html += `<div style="overflow-x:auto; margin-bottom:16px;">
            <table style="width:100%; border-collapse:collapse; font-size:10px; color:#cbd5e1;">
                <thead><tr style="border-bottom:1px solid #334155;">
                    <th style="padding:6px 4px; text-align:left; color:#94a3b8;">Month</th>
                    <th style="padding:6px 4px; text-align:right; color:#94a3b8;">Charged</th>
                    <th style="padding:6px 4px; text-align:right; color:#94a3b8;">Discharged</th>
                    <th style="padding:6px 4px; text-align:right; color:#94a3b8;">Cycles</th>
                    <th style="padding:6px 4px; text-align:right; color:#94a3b8;">Avg SoC</th>
                    <th style="padding:6px 4px; text-align:right; color:#94a3b8;">Grid Import</th>
                    <th style="padding:6px 4px; text-align:right; color:#94a3b8;">Self-Consumed</th>
                </tr></thead><tbody>`;
            const mNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            ba.monthly.forEach((m, i) => {
                html += `<tr style="border-bottom:1px solid rgba(51,65,85,0.5);">
                    <td style="padding:4px;">${mNames[i]}</td>
                    <td style="padding:4px; text-align:right; color:var(--success);">${m.charged.toFixed(0)} kWh</td>
                    <td style="padding:4px; text-align:right; color:var(--purple);">${m.discharged.toFixed(0)} kWh</td>
                    <td style="padding:4px; text-align:right;">${m.cycles.toFixed(1)}</td>
                    <td style="padding:4px; text-align:right; color:var(--orange);">${m.avgSocPct.toFixed(0)}%</td>
                    <td style="padding:4px; text-align:right; color:var(--err);">${m.gridImport.toFixed(0)} kWh</td>
                    <td style="padding:4px; text-align:right; color:var(--success);">${m.selfConsumedPct.toFixed(0)}%</td>
                </tr>`;
            });
            html += `</tbody></table></div>`;

            // 4B. Overnight Load Coverage
            const ov = ba.overnight;
            const ovCovPct = ov.nightsTotal > 0 ? (ov.nightsCovered / ov.nightsTotal * 100) : 0;
            html += `<h3 style="margin:16px 0 12px 0; font-size:14px; color:var(--purple);">Overnight Load Coverage (6PM–6AM)</h3>`;
            html += `<div style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:8px;">
                <div style="text-align:center; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:18px; font-weight:700; color:${ovCovPct >= 80 ? 'var(--success)' : ovCovPct >= 50 ? 'var(--warn)' : 'var(--err)'};">${ov.nightsCovered}/${ov.nightsTotal}</div>
                    <div style="font-size:9px; color:#94a3b8;">Nights Fully Covered</div>
                </div>
                <div style="text-align:center; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:18px; font-weight:700; color:var(--err);">${(ov.totalLoadKwh / Math.max(1, ov.nightsTotal)).toFixed(1)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Avg Overnight Load kWh</div>
                </div>
                <div style="text-align:center; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:18px; font-weight:700; color:var(--orange);">${(ov.totalBattKwh / Math.max(1, ov.nightsTotal)).toFixed(1)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Avg Battery kWh/Night</div>
                </div>
                <div style="text-align:center; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:18px; font-weight:700; color:var(--accent);">${ovCovPct.toFixed(0)}%</div>
                    <div style="font-size:9px; color:#94a3b8;">Coverage Rate</div>
                </div>
            </div>`;
            html += `<div style="display:flex; gap:16px; font-size:10px; color:#94a3b8; margin-bottom:16px; padding:6px 8px; background:rgba(0,0,0,0.2); border-radius:4px;">
                <span>Summer: <strong style="color:var(--warn);">${ov.summerCovered}/${ov.summerTotal}</strong> nights</span>
                <span>Winter: <strong style="color:var(--accent);">${ov.winterCovered}/${ov.winterTotal}</strong> nights</span>
                <span>Overnight Grid: <strong style="color:var(--err);">${ov.totalGridKwh.toFixed(0)} kWh/yr</strong></span>
            </div>`;

            // 4C. Grid Dependency by Hour-of-Day (stacked bar chart)
            html += `<h3 style="margin:16px 0 12px 0; font-size:14px; color:var(--warn);">Grid Dependency by Hour of Day</h3>`;
            const hr = ba.hourly;
            let hrMax = 1;
            for(let h = 0; h < 24; h++) hrMax = Math.max(hrMax, hr.solar[h] + hr.battery[h] + hr.grid[h]);
            const gcH = 100;
            let gcHtml = `<div style="position:relative; height:${gcH + 22}px; background:rgba(0,0,0,0.3); border-radius:4px; padding-left:32px; padding-bottom:18px; margin-bottom:16px; overflow:hidden;">`;
            // Y-axis labels
            for(let i = 0; i <= 4; i++) {
                const val = (hrMax * i / 4);
                const y = gcH - (i / 4) * gcH;
                gcHtml += `<div style="position:absolute; left:0; top:${y}px; width:28px; text-align:right; font-size:7px; color:#64748b; transform:translateY(-4px);">${val.toFixed(0)}</div>`;
                gcHtml += `<div style="position:absolute; left:32px; right:0; top:${y}px; height:1px; background:rgba(255,255,255,0.04);"></div>`;
            }
            // 24 stacked bars
            for(let h = 0; h < 24; h++) {
                const x = (h / 24 * 100).toFixed(1);
                const bw = (100 / 24 * 0.8).toFixed(1);
                const sH = (hr.solar[h] / hrMax * gcH);
                const btH = (hr.battery[h] / hrMax * gcH);
                const gH = (hr.grid[h] / hrMax * gcH);
                // Stack: solar bottom, battery middle, grid top
                gcHtml += `<div style="position:absolute; bottom:18px; left:calc(32px + ${x}%); width:${bw}%; height:${sH}px; background:var(--warn); opacity:0.7; border-radius:1px 1px 0 0;"></div>`;
                gcHtml += `<div style="position:absolute; bottom:${18 + sH}px; left:calc(32px + ${x}%); width:${bw}%; height:${btH}px; background:var(--orange); opacity:0.7;"></div>`;
                gcHtml += `<div style="position:absolute; bottom:${18 + sH + btH}px; left:calc(32px + ${x}%); width:${bw}%; height:${gH}px; background:var(--err); opacity:0.7; border-radius:1px 1px 0 0;"></div>`;
                // X label every 3 hours
                if(h % 3 === 0) gcHtml += `<div style="position:absolute; bottom:2px; left:calc(32px + ${x}%); font-size:7px; color:#64748b;">${h}:00</div>`;
            }
            gcHtml += `</div>`;
            gcHtml += `<div style="display:flex; gap:12px; font-size:9px; color:#94a3b8; margin-bottom:16px;">
                <span><span style="display:inline-block; width:8px; height:8px; background:var(--warn); border-radius:1px; vertical-align:middle;"></span> Solar</span>
                <span><span style="display:inline-block; width:8px; height:8px; background:var(--orange); border-radius:1px; vertical-align:middle;"></span> Battery</span>
                <span><span style="display:inline-block; width:8px; height:8px; background:var(--err); border-radius:1px; vertical-align:middle;"></span> Grid</span>
            </div>`;
            html += gcHtml;

            // 4D. Battery Efficiency Breakdown
            const eff = ba.efficiency;
            html += `<h3 style="margin:16px 0 12px 0; font-size:14px; color:var(--success);">Battery Efficiency</h3>`;
            html += `<div style="display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-bottom:16px;">
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--success);">${(eff.dcChargeEff * 100).toFixed(1)}%</div>
                    <div style="font-size:8px; color:#94a3b8;">Charge Eff</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--success);">${(eff.dischargeEff * 100).toFixed(1)}%</div>
                    <div style="font-size:8px; color:#94a3b8;">Discharge Eff</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:${eff.effectiveRoundTrip >= 0.85 ? 'var(--success)' : 'var(--warn)'};">${(eff.effectiveRoundTrip * 100).toFixed(1)}%</div>
                    <div style="font-size:8px; color:#94a3b8;">Round-Trip</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--err);">${eff.totalLossKwh.toFixed(0)}</div>
                    <div style="font-size:8px; color:#94a3b8;">Loss kWh</div>
                </div>
                <div style="text-align:center; padding:8px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:16px; font-weight:700; color:var(--text);">${eff.lossPctOfProduction.toFixed(1)}%</div>
                    <div style="font-size:8px; color:#94a3b8;">% of Production</div>
                </div>
            </div>`;

            // 4E. 10-Year Degradation Table
            html += `<h3 style="margin:16px 0 12px 0; font-size:14px; color:var(--orange);">10-Year Degradation Projection (LFP 2.5%/yr)</h3>`;
            html += `<div style="overflow-x:auto; margin-bottom:16px;">
            <table style="width:100%; border-collapse:collapse; font-size:10px; color:#cbd5e1;">
                <thead><tr style="border-bottom:1px solid #334155;">
                    <th style="padding:5px 3px; text-align:left; color:#94a3b8;">Year</th>
                    <th style="padding:5px 3px; text-align:right; color:#94a3b8;">Capacity</th>
                    <th style="padding:5px 3px; text-align:right; color:#94a3b8;">Retained</th>
                    <th style="padding:5px 3px; text-align:right; color:#94a3b8;">Cycles/Yr</th>
                    <th style="padding:5px 3px; text-align:right; color:#94a3b8;">Cumulative</th>
                    <th style="padding:5px 3px; text-align:right; color:#94a3b8;">Warranty</th>
                </tr></thead><tbody>`;
            ba.degradation.forEach(d => {
                const wColor = d.warrantyOk ? 'var(--success)' : 'var(--err)';
                html += `<tr style="border-bottom:1px solid rgba(51,65,85,0.3);">
                    <td style="padding:3px;">${d.year}</td>
                    <td style="padding:3px; text-align:right;">${d.capacityKwh.toFixed(1)} kWh</td>
                    <td style="padding:3px; text-align:right; color:${d.retainedPct >= 80 ? 'var(--success)' : d.retainedPct >= 70 ? 'var(--warn)' : 'var(--err)'};">${d.retainedPct.toFixed(1)}%</td>
                    <td style="padding:3px; text-align:right;">${d.estCycles.toFixed(0)}</td>
                    <td style="padding:3px; text-align:right;">${d.cumCycles.toFixed(0)}</td>
                    <td style="padding:3px; text-align:right; color:${wColor};">${d.warrantyOk ? '✓' : '✗'}</td>
                </tr>`;
            });
            html += `</tbody></table></div>`;

            // 4F. Economic Value Analysis
            const econ = ba.economic;
            const rates = APP.utilityRates;
            html += `<h3 style="margin:16px 0 12px 0; font-size:14px; color:var(--success);">Economic Value Analysis</h3>`;
            html += `<div style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:8px;">
                <div style="text-align:center; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:18px; font-weight:700; color:var(--orange);">${econ.peakDischKwh.toFixed(0)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Peak Discharge kWh</div>
                </div>
                <div style="text-align:center; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:18px; font-weight:700; color:var(--success);">$${econ.annualSavings.toFixed(0)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Annual Savings</div>
                </div>
                <div style="text-align:center; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:18px; font-weight:700; color:var(--err);">${econ.withoutBatteryGridKwh.toFixed(0)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Grid kWh w/o Battery</div>
                </div>
                <div style="text-align:center; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">
                    <div style="font-size:18px; font-weight:700; color:var(--accent);">${Math.round(eb.gridImport)}</div>
                    <div style="font-size:9px; color:#94a3b8;">Grid kWh w/ Battery</div>
                </div>
            </div>`;
            html += `<div style="font-size:10px; color:#94a3b8; padding:6px 8px; background:rgba(0,0,0,0.2); border-radius:4px; margin-bottom:16px;">
                Rates: Standard $${rates.standard.toFixed(2)}/kWh | Peak $${rates.peak.toFixed(2)}/kWh | Off-Peak $${rates.offPeak.toFixed(2)}/kWh —
                Savings = peak grid import avoided × (peak - standard) rate differential.
                <br><span style="color:var(--warn);">Per CO/Xcel: Battery charges from PV only, no grid export from battery.</span>
            </div>`;

            // Grid Independence card
            html += `<div style="text-align:center; padding:12px; background:rgba(52,211,153,0.1); border:1px solid var(--success); border-radius:6px; margin-bottom:16px;">
                <div style="font-size:24px; font-weight:700; color:var(--success);">${ba.gridIndependencePct.toFixed(1)}%</div>
                <div style="font-size:11px; color:#94a3b8;">Grid Independence — Home load met by solar + battery</div>
            </div>`;
        }

        // Consumption profile chart
        if(hasConsumption && APP.homeConsumption.profile) {
            html += `<h3 style="margin:16px 0 12px 0; font-size:14px; color:var(--err);">Home Consumption Profile (Monthly Average)</h3>`;
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            const monthlyAvgW = [];
            for(let m = 0; m < 12; m++) {
                const ds = Math.floor((new Date(2024, m, 1) - new Date(2024,0,1)) / 86400000);
                const de = Math.min(365, Math.floor((new Date(2024, m+1, 1) - new Date(2024,0,1)) / 86400000));
                let sum = 0, count = 0;
                for(let d = ds; d < de; d++) {
                    for(let h = 0; h < 48; h++) { sum += APP.homeConsumption.profile[d*48+h]; count++; }
                }
                monthlyAvgW.push(count > 0 ? sum / count : 0);
            }
            const maxW = Math.max(...monthlyAvgW, 1);
            let cHtml = `<div style="display:flex; gap:4px; align-items:flex-end; height:80px; padding:0 4px;">`;
            monthlyAvgW.forEach((w, m) => {
                const h = (w / maxW * 70);
                cHtml += `<div style="flex:1; text-align:center;">
                    <div style="height:${h}px; background:var(--err); opacity:0.6; border-radius:2px 2px 0 0; margin:0 auto; width:80%;"></div>
                    <div style="font-size:7px; color:#64748b; margin-top:2px;">${monthNames[m]}</div>
                    <div style="font-size:7px; color:#94a3b8;">${(w/1000).toFixed(1)}kW</div>
                </div>`;
            });
            cHtml += '</div>';
            html += cHtml;
        }

        // Dispatch mode info
        const modeNames = { self: 'Self-Consumption', tou: 'Time-of-Use', export: 'Export-First' };
        html += `<div style="margin-top:16px; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px; font-size:10px; color:#94a3b8;">
            <strong>Dispatch Mode:</strong> ${modeNames[APP.homeConsumption.priorityMode] || 'Self-Consumption'} |
            <strong>Export Limit:</strong> ${APP.exportLimitW > 0 ? (APP.exportLimitW/1000).toFixed(1) + ' kW' : 'Unlimited'} |
            <strong>Home Load:</strong> ${hasConsumption ? (APP.homeConsumption.annualKwh / 365 / 24).toFixed(2) + ' kW avg' : 'Not configured'}
        </div>`;

        container.innerHTML = html;
    },

    renderInverterView: () => {
        const container = document.getElementById('inverterGrid');

        if(APP.inverters.length === 0) {
            container.innerHTML = '<div style="color:#64748b; text-align:center; padding-top:50px;">Add inverters in the right panel and assign strings to see analysis</div>';
            return;
        }

        const chartMode = APP.invChartMode;
        let html = '';

        // System-wide clipping summary (now distinguishes true clipping from battery charging)
        const totalClipEvents = APP.clippingEvents.length;
        const totalBattChgEvents = APP.batteryChargingEvents.length;
        const totalClipHrs = APP.clippingEvents.reduce((a,e) => a + e.durationMin, 0) / 60;
        const totalClipKwh = APP.clippingEvents.reduce((a,e) => a + e.totalClipWh, 0);
        const totalBattChgKwh = APP.batteryChargingEvents.reduce((a,e) => a + e.totalKwh, 0);
        const exportLimitStr = APP.exportLimitW > 0 ? `${(APP.exportLimitW/1000).toFixed(1)} kW` : 'None';

        html += `
            <div style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:10px;">
                <div class="stat-item"><span class="stat-val-sm" style="color:${totalClipEvents > 0 ? 'var(--warn)' : 'var(--success)'};">${totalClipEvents}</span><span class="stat-name">True Clip Events</span></div>
                <div class="stat-item"><span class="stat-val-sm">${totalClipHrs.toFixed(0)}h</span><span class="stat-name">Clip Duration</span></div>
                <div class="stat-item"><span class="stat-val-sm">${totalClipKwh.toFixed(1)}</span><span class="stat-name">kWh Clipped</span></div>
                <div class="stat-item"><span class="stat-val-sm">${(APP.clippingThreshold*100).toFixed(0)}%</span><span class="stat-name">Threshold</span></div>
            </div>
            ${!APP.hasShade ? (() => {
                const _dcCap = APP.geo.length * APP.panel.watts;
                const _acCap = APP.inverters.reduce((a, inv) => a + (inv.spec || EQUIPMENT.inverters[inv.typeKey]).acPower, 0) || 1;
                const _npRatio = _dcCap / _acCap;
                const _avgT = APP.panelStats.length > 0 ? APP.panelStats.reduce((a,p) => a + (p.tsrf || 0.8), 0) / APP.panelStats.length : 0.8;
                const _sumT = APP.getSeasonalTSRF(_avgT, 172);
                const _sumRatio = (_dcCap * _sumT) / _acCap;
                return `<div style="background:rgba(250,204,21,0.1); border:1px solid var(--warn); border-radius:6px; padding:8px; margin-bottom:10px; font-size:10px;">
                    <div style="font-weight:700; color:var(--warn); margin-bottom:4px;">No Shade Data — Seasonal TSRF Decomposition Active</div>
                    <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:6px;">
                        <div class="stat-item"><span class="stat-val-sm">${_npRatio.toFixed(2)}</span><span class="stat-name">Nameplate DC/AC</span></div>
                        <div class="stat-item"><span class="stat-val-sm" style="color:${_sumRatio > 1.0 ? 'var(--warn)' : 'var(--success)'};">${_sumRatio.toFixed(2)}</span><span class="stat-name">Summer Peak DC/AC</span></div>
                        <div class="stat-item"><span class="stat-val-sm">${(_sumT * 100).toFixed(0)}%</span><span class="stat-name">Summer TSRF Est.</span></div>
                    </div>
                    <div style="color:#94a3b8; margin-top:4px;">
                        Annual TSRF (${(_avgT * 100).toFixed(0)}%) decomposed seasonally. Summer peak uses estimated ${(_sumT * 100).toFixed(0)}% TSRF.
                        ${_sumRatio > 1.0 ? '<span style="color:var(--warn);"> Clipping expected in summer.</span>' : '<span style="color:var(--success);"> No clipping expected.</span>'}
                        Load EVIA shade data for precise analysis.
                    </div>
                </div>`;
            })() : ''}
            ${totalBattChgEvents > 0 ? `
            <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:10px;">
                <div class="stat-item" style="border-color:#22d3ee;"><span class="stat-val-sm" style="color:#22d3ee;">${totalBattChgEvents}</span><span class="stat-name">DC Charging Sessions</span></div>
                <div class="stat-item" style="border-color:#22d3ee;"><span class="stat-val-sm" style="color:#22d3ee;">${totalBattChgKwh.toFixed(1)}</span><span class="stat-name">kWh → Battery (DC)</span></div>
                <div class="stat-item" style="border-color:#22d3ee;"><span class="stat-val-sm" style="color:#22d3ee;">Not Clipping</span><span class="stat-name">Battery Absorbed Excess</span></div>
            </div>` : ''}
            ${APP.exportLimitW > 0 || APP.homeConsumption.enabled ? `
            <div style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:10px;">
                <div class="stat-item"><span class="stat-val-sm">${exportLimitStr}</span><span class="stat-name">Export Limit</span></div>
                <div class="stat-item"><span class="stat-val-sm">${APP.exportCurtailed.toFixed(1)}</span><span class="stat-name">kWh Curtailed</span></div>
                <div class="stat-item"><span class="stat-val-sm">${APP.homeConsumption.enabled ? Math.round(APP.homeConsumption.annualKwh).toLocaleString() : 'N/A'}</span><span class="stat-name">Home kWh/yr</span></div>
                <div class="stat-item"><span class="stat-val-sm">${APP.energyBalance.selfConsumed > 0 ? (APP.energyBalance.selfConsumed / APP.energyBalance.totalProduction * 100).toFixed(1) + '%' : 'N/A'}</span><span class="stat-name">Self-Consume</span></div>
            </div>` : ''}
            ${APP.batteryState.some(b => b !== null) ? `
            <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:10px;">
                <div class="stat-item"><span class="stat-val-sm" style="color:var(--orange);">${Math.round(APP.energyBalance.batteryCharged)}</span><span class="stat-name">Battery Charged kWh</span></div>
                <div class="stat-item"><span class="stat-val-sm" style="color:var(--purple);">${Math.round(APP.energyBalance.batteryDischarged)}</span><span class="stat-name">Discharged kWh</span></div>
                <div class="stat-item"><span class="stat-val-sm" style="color:var(--success);">${(APP.energyBalance.clipped + APP.energyBalance.curtailed).toFixed(1)}</span><span class="stat-name">Total Lost kWh</span></div>
            </div>` : ''}
            <!-- Chart mode tabs -->
            <div style="display:flex; gap:2px; margin-bottom:12px;">
                <button class="btn-sm" onclick="APP.setInvChartMode('daily')" style="background:${chartMode==='daily'?'var(--accent)':'#475569'}; color:${chartMode==='daily'?'#0f172a':'white'};">Daily</button>
                <button class="btn-sm" onclick="APP.setInvChartMode('weekly')" style="background:${chartMode==='weekly'?'var(--accent)':'#475569'}; color:${chartMode==='weekly'?'#0f172a':'white'};">Weekly</button>
                <button class="btn-sm" onclick="APP.setInvChartMode('monthly')" style="background:${chartMode==='monthly'?'var(--accent)':'#475569'}; color:${chartMode==='monthly'?'#0f172a':'white'};">Monthly</button>
            </div>`;

        APP.inverters.forEach((inv, invIdx) => {
            const spec = inv.spec || EQUIPMENT.inverters[inv.typeKey];
            const tsData = APP.inverterTimeseries[invIdx];
            const clipLineW = spec.acPower * APP.clippingThreshold;

            // Compute stats
            let totalDC = 0, totalAC = 0, totalClip = 0, peakDC = 0;
            if(tsData) { tsData.forEach(t => { totalDC += t.dcInput; totalAC += t.acOutput; totalClip += t.clippedW; peakDC = Math.max(peakDC, t.dcInput); }); }
            const annualDCkwh = totalDC / 2000;
            const annualACkwh = totalAC / 2000;
            const annualClipkwh = totalClip / 2000;
            const clipPercent = totalDC > 0 ? (totalClip / totalDC * 100) : 0;
            const maxClipPct = (peakDC / spec.acPower) * 100;
            const threshPct = APP.clippingThreshold * 100;
            const overThreshPct = maxClipPct - threshPct; // how many % points over threshold

            // Color logic: >10% over threshold = red, 0-10% over = yellow, under = green
            const maxClipColor = overThreshPct > 10 ? 'var(--err)' : overThreshPct > 0 ? 'var(--warn)' : 'var(--success)';
            const invEvents = APP.clippingEvents.filter(e => e.inverterId === invIdx);
            const invBattEvents = APP.batteryChargingEvents.filter(e => e.invIdx === invIdx);

            // Compute daily peak DC for all 365 days
            const dailyPeakDC = new Array(365).fill(0);
            if(tsData) {
                for(let d = 0; d < 365; d++) {
                    let dayPeak = 0;
                    for(let h = 0; h < 48; h++) dayPeak = Math.max(dayPeak, tsData[d*48+h].dcInput);
                    dailyPeakDC[d] = dayPeak;
                }
            }

            // Build chart data based on mode
            let chartData = []; // [{label, value, dayStart, dayEnd}]
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            if(chartMode === 'daily') {
                for(let d = 0; d < 365; d++) {
                    const dt = new Date(2024, 0, d + 1);
                    chartData.push({ label: dt.toLocaleDateString('default',{month:'short',day:'numeric'}), value: dailyPeakDC[d], dayStart: d, dayEnd: d+1 });
                }
            } else if(chartMode === 'weekly') {
                for(let w = 0; w < 52; w++) {
                    const ds = w * 7; const de = Math.min(365, ds + 7);
                    let peak = 0; for(let d = ds; d < de; d++) peak = Math.max(peak, dailyPeakDC[d]);
                    const dt = new Date(2024, 0, ds + 1);
                    chartData.push({ label: 'W' + (w+1) + ' ' + dt.toLocaleDateString('default',{month:'short',day:'numeric'}), value: peak, dayStart: ds, dayEnd: de });
                }
            } else {
                for(let m = 0; m < 12; m++) {
                    const ds = Math.floor((new Date(2024, m, 1) - new Date(2024,0,1)) / 86400000);
                    const de = Math.min(365, Math.floor((new Date(2024, m+1, 1) - new Date(2024,0,1)) / 86400000));
                    let peak = 0; for(let d = ds; d < de; d++) peak = Math.max(peak, dailyPeakDC[d]);
                    chartData.push({ label: monthNames[m], value: peak, dayStart: ds, dayEnd: de });
                }
            }

            const chartMax = Math.max(...chartData.map(c => c.value), clipLineW, 1);
            const chartH = 120;
            const barCount = chartData.length;
            const daysOverThreshold = chartData.filter(c => c.value > clipLineW).length;

            // Build chart HTML
            let chartHtml = `<div style="position:relative; height:${chartH + 30}px; background:rgba(0,0,0,0.3); border-radius:4px; margin-bottom:8px; padding-left:40px; padding-bottom:20px; overflow:visible;">`;
            // Y-axis labels
            for(let i = 0; i <= 3; i++) {
                const val = (chartMax / 3) * (3 - i);
                const y = (i / 3) * chartH;
                chartHtml += `<div style="position:absolute; left:0; top:${y}px; width:36px; text-align:right; font-size:7px; color:#64748b; transform:translateY(-4px);">${(val/1000).toFixed(1)}kW</div>`;
                chartHtml += `<div style="position:absolute; left:40px; right:0; top:${y}px; height:1px; background:rgba(255,255,255,0.04);"></div>`;
            }
            // Threshold line
            const threshY = chartH - (clipLineW / chartMax) * chartH;
            chartHtml += `<div style="position:absolute; left:40px; right:0; top:${threshY}px; border-top:2px dashed var(--err); z-index:2;"></div>`;
            chartHtml += `<div style="position:absolute; right:4px; top:${threshY - 12}px; font-size:7px; color:var(--err); z-index:3;">${(clipLineW/1000).toFixed(1)}kW (${threshPct.toFixed(0)}%)</div>`;

            // Bars
            chartData.forEach((c, i) => {
                const bw = Math.max(1, Math.floor((100 - 2) / barCount * 0.85));
                const leftPct = 2 + (i / barCount) * 96;
                const h = (c.value / chartMax) * chartH;
                const isOver = c.value > clipLineW;
                const isSelected = APP.invSelectedDay >= c.dayStart && APP.invSelectedDay < c.dayEnd;
                const bg = isOver ? 'var(--warn)' : 'var(--accent)';
                const border = isSelected ? '2px solid white' : 'none';
                chartHtml += `<div style="position:absolute; bottom:20px; left:calc(40px + ${leftPct}%); width:${bw}%; height:${h}px; background:${bg}; border-radius:1px 1px 0 0; cursor:pointer; border:${border};" title="${c.label}: ${(c.value/1000).toFixed(2)} kW${isOver ? ' [EXCEEDS]' : ''}" onclick="APP.selectInvDay(${invIdx}, ${c.dayStart})"></div>`;
            });

            // X-axis labels
            if(chartMode === 'monthly') {
                chartHtml += '<div style="position:absolute; bottom:0; left:40px; right:0; display:flex; justify-content:space-around; font-size:7px; color:#64748b;">';
                monthNames.forEach(m => { chartHtml += `<span>${m}</span>`; });
                chartHtml += '</div>';
            } else if(chartMode === 'weekly') {
                chartHtml += '<div style="position:absolute; bottom:0; left:40px; right:0; display:flex; justify-content:space-between; font-size:6px; color:#64748b;">';
                for(let w = 0; w < 52; w += 4) { chartHtml += `<span>W${w+1}</span>`; }
                chartHtml += '</div>';
            } else {
                chartHtml += '<div style="position:absolute; bottom:0; left:40px; right:0; display:flex; justify-content:space-between; font-size:6px; color:#64748b;">';
                monthNames.forEach(m => { chartHtml += `<span>${m}</span>`; });
                chartHtml += '</div>';
            }
            chartHtml += '</div>';

            // If a day is selected, show its 30-min profile
            let dayProfileHtml = '';
            if(APP.invSelectedDay >= 0 && tsData) {
                const sd = APP.invSelectedDay;
                const dt = new Date(2024, 0, sd + 1);
                const dayLabel = dt.toLocaleDateString('default', {weekday:'short', month:'short', day:'numeric'});
                const dayData = new Array(48).fill(0);
                for(let h = 0; h < 48; h++) dayData[h] = tsData[sd * 48 + h].dcInput;
                const dayMax = Math.max(...dayData, clipLineW, 1);
                const dayPeak = Math.max(...dayData);

                dayProfileHtml = `
                <div style="font-size:9px; color:var(--accent); margin-bottom:4px; font-weight:600;">${dayLabel} — 30-min DC Profile | Peak: ${(dayPeak/1000).toFixed(2)} kW</div>
                <div style="position:relative; height:70px; background:rgba(0,0,0,0.2); border-radius:4px; margin-bottom:6px; padding-left:32px; padding-bottom:14px; overflow:visible;">
                    <div style="position:absolute; left:0; top:0; bottom:14px; width:30px; display:flex; flex-direction:column; justify-content:space-between; align-items:flex-end; padding-right:2px; font-size:7px; color:#64748b;">
                        <span>${(dayMax/1000).toFixed(1)}</span><span>0 kW</span>
                    </div>
                    ${dayData.map((v, i) => {
                        const bh = (v / dayMax) * 52;
                        const isClip = v > clipLineW;
                        return `<div style="position:absolute; bottom:14px; left:${32 + i * ((100-32)/48)}%; width:${(100-32)/48 - 0.3}%; height:${bh}px; background:${isClip ? 'var(--warn)' : 'var(--accent)'}; border-radius:1px 1px 0 0;" title="${Math.floor(i/2)}:${(i%2)*30||'00'} ${(v/1000).toFixed(2)}kW"></div>`;
                    }).join('')}
                    <div style="position:absolute; bottom:${14 + (clipLineW / dayMax) * 52}px; left:32px; right:0; border-top:1px dashed var(--err);"></div>
                    <div style="position:absolute; bottom:0; left:32px; right:0; display:flex; justify-content:space-between; font-size:6px; color:#64748b;">
                        <span>0:00</span><span>6:00</span><span>12:00</span><span>18:00</span><span>24:00</span>
                    </div>
                </div>`;
            }

            html += `
                <div class="inv-card" style="border-color:${maxClipColor}33;">
                    <div class="inv-header">
                        <span>${inv.name}: ${spec.name}</span>
                        <span style="font-weight:bold;">
                            <span style="color:${maxClipColor};">Max Clip: ${maxClipPct.toFixed(1)}%${overThreshPct > 0 ? ' ⚠' : ' ✓'}</span>
                            <span style="color:#94a3b8; font-weight:normal; margin-left:8px;">${clipPercent > 0 ? clipPercent.toFixed(1) + '% clipped' : 'No clipping'}</span>
                        </span>
                    </div>
                    <div style="font-size:10px; color:#94a3b8; margin-bottom:6px;">
                        Strings: ${inv.strings.map(s => `<span style="color:${APP.strings[s]?.color || '#666'}">S${s+1}</span>`).join(', ') || 'None'}
                    </div>
                    <div class="inv-stats" style="margin-bottom:8px;">
                        <div class="inv-stat">DC In: ${annualDCkwh.toFixed(0)} kWh/yr</div>
                        <div class="inv-stat">AC Out: ${annualACkwh.toFixed(0)} kWh/yr</div>
                        <div class="inv-stat">Clipped: ${annualClipkwh.toFixed(1)} kWh</div>
                        <div class="inv-stat">Peak DC: ${(peakDC/1000).toFixed(2)} kW</div>
                        <div class="inv-stat">AC Rating: ${(spec.acPower/1000).toFixed(1)} kW</div>
                        <div class="inv-stat">DC/AC: ${(peakDC/spec.acPower).toFixed(2)}</div>
                        <div class="inv-stat" style="${!APP.hasShade ? 'color:var(--warn);' : ''}">Nameplate: ${(inv.strings.reduce((a, sIdx) => a + (APP.strings[sIdx]?.panels?.length || 0), 0) * APP.panel.watts / spec.acPower).toFixed(2)}</div>
                        <div class="inv-stat" style="color:${maxClipColor};">Max Clip: ${maxClipPct.toFixed(1)}%</div>
                        <div class="inv-stat">Days Over: ${daysOverThreshold} / ${chartMode === 'daily' ? 365 : chartData.length}</div>
                    </div>

                    <!-- Peak DC Chart -->
                    <div style="font-size:9px; color:#94a3b8; margin-bottom:3px; display:flex; justify-content:space-between;">
                        <span>${chartMode === 'daily' ? 'Daily' : chartMode === 'weekly' ? 'Weekly' : 'Monthly'} Peak DC Input</span>
                        <span>Threshold: ${threshPct.toFixed(0)}% = ${(clipLineW/1000).toFixed(1)} kW | ${daysOverThreshold} over</span>
                    </div>
                    ${chartHtml}
                    ${dayProfileHtml}

                    ${invEvents.length > 0 ? `
                    <details style="font-size:10px;">
                        <summary style="cursor:pointer; color:${overThreshPct > 0 ? maxClipColor : 'var(--accent)'}; font-weight:600; margin-bottom:4px;">
                            ${invEvents.length} True Clipping Events (${(invEvents.reduce((a,e) => a + e.durationMin, 0) / 60).toFixed(0)} hrs, ${invEvents.reduce((a,e) => a + e.totalClipWh, 0).toFixed(1)} kWh lost)
                        </summary>
                        <div style="max-height:150px; overflow-y:auto;">
                            <table class="clip-log-table">
                                <thead><tr><th>Date</th><th>Start</th><th>End</th><th>Duration</th><th>Peak</th></tr></thead>
                                <tbody>
                                    ${invEvents.slice(0, 50).map(e => `<tr>
                                        <td>${e.date}</td>
                                        <td>${e.startTime}</td>
                                        <td>${e.endTime}</td>
                                        <td>${(e.durationMin/60).toFixed(1)}h</td>
                                        <td>${(e.peakClipW/1000).toFixed(2)}kW</td>
                                    </tr>`).join('')}
                                    ${invEvents.length > 50 ? `<tr><td colspan="5" style="color:#64748b;">...and ${invEvents.length - 50} more events</td></tr>` : ''}
                                </tbody>
                            </table>
                        </div>
                    </details>` : ''}
                    ${invBattEvents.length > 0 ? `
                    <details style="font-size:10px;">
                        <summary style="cursor:pointer; color:#22d3ee; font-weight:600; margin-bottom:4px;">
                            ${invBattEvents.length} Battery Charging Sessions (${invBattEvents.reduce((a,e) => a + e.totalKwh, 0).toFixed(1)} kWh absorbed — not clipping)
                        </summary>
                        <div style="font-size:9px; color:#64748b; margin-bottom:4px; padding:4px; background:rgba(34,211,238,0.1); border-radius:3px;">
                            DC excess absorbed by battery before reaching inverter. Combined AC+DC throughput: ${((spec.acPower * APP.clippingThreshold + (APP.batteryConfig[invIdx]?.totalDcChargeW || 0)) / 1000).toFixed(1)} kW
                        </div>
                        <div style="max-height:100px; overflow-y:auto;">
                            <table class="clip-log-table">
                                <thead><tr><th>Date</th><th>Peak DC→Batt</th><th>kWh</th></tr></thead>
                                <tbody>
                                    ${invBattEvents.slice(0, 30).map(e => `<tr>
                                        <td>${e.date}</td>
                                        <td>${(e.peakW/1000).toFixed(2)}kW</td>
                                        <td>${e.totalKwh.toFixed(2)}</td>
                                    </tr>`).join('')}
                                    ${invBattEvents.length > 30 ? `<tr><td colspan="3" style="color:#64748b;">...and ${invBattEvents.length - 30} more</td></tr>` : ''}
                                </tbody>
                            </table>
                        </div>
                    </details>` : ''}
                </div>
            `;
        });

        container.innerHTML = html;
    },

    // ============== AI ANALYSIS ==============
    generateAIAnalysis: () => {
        const container = document.getElementById('aiContent');
        if(!APP.panelStats.length) return;

        const lowTSRF = APP.panelStats.filter(p => p.tsrf < 0.7);
        const veryLowTSRF = APP.panelStats.filter(p => p.tsrf < 0.5);

        const issues = [];
        const recommendations = [];

        if(lowTSRF.length > 0) {
            issues.push({
                icon: '\uD83C\uDF11',
                title: 'Shading Detected',
                desc: `${lowTSRF.length} panels have TSRF below 70%. These may limit string performance via current mismatch.`
            });
            recommendations.push(`Consider isolating panels ${lowTSRF.map(p => p.id).join(', ')} on separate strings or using microinverters.`);
        }

        if(veryLowTSRF.length > 0) {
            issues.push({
                icon: '\u26A0\uFE0F',
                title: 'Severe Shading',
                desc: `${veryLowTSRF.length} panels have TSRF below 50%. Consider removing or relocating.`
            });
        }

        // Mismatch analysis per string
        APP.strings.forEach((str, idx) => {
            const tsrfs = str.panels.map(pIdx => APP.panelStats[pIdx]?.tsrf || 0);
            const minTSRF = Math.min(...tsrfs);
            const maxTSRF = Math.max(...tsrfs);
            if(maxTSRF - minTSRF > 0.2) {
                issues.push({
                    icon: '\u26A1',
                    title: `String ${idx+1} Mismatch`,
                    desc: `TSRF varies from ${(minTSRF*100).toFixed(0)}% to ${(maxTSRF*100).toFixed(0)}%. Bypass diodes will activate, limiting string current to weakest panel.`
                });
                recommendations.push(`Re-string String ${idx+1} to group panels with similar shade profiles.`);
            }
        });

        // Clipping analysis
        if(APP.clippingLoss > 5) {
            issues.push({
                icon: '\uD83D\uDCC9',
                title: 'High Clipping Loss',
                desc: `${APP.clippingLoss.toFixed(1)}% of production is lost to inverter clipping across ${APP.clippingEvents.length} events.`
            });
            recommendations.push('Consider a larger inverter, adding another inverter, or battery storage to capture excess production.');
        }

        // Triple model comparison
        const indepTotal = APP.panelTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const stringTotal = APP.stringTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const evTotal = APP.eagleViewProduction.annual;
        const mismatchLoss = indepTotal > 0 ? ((indepTotal - stringTotal) / indepTotal * 100) : 0;

        if(evTotal > 0 && indepTotal > 0) {
            const deltaEV = ((indepTotal - evTotal) / evTotal * 100);
            issues.push({
                icon: '\uD83D\uDCCA',
                title: 'Production Model Comparison',
                desc: `Independent: ${Math.round(indepTotal).toLocaleString()} kWh | String: ${Math.round(stringTotal).toLocaleString()} kWh | EagleView: ${Math.round(evTotal).toLocaleString()} kWh. Mismatch loss: ${mismatchLoss.toFixed(1)}%. Delta vs EagleView: ${deltaEV > 0 ? '+' : ''}${deltaEV.toFixed(1)}%.`
            });
        }

        // DC/AC ratio
        const dcCapacity = (APP.geo.length * APP.panel.watts);
        let totalACCapacity = APP.inverters.reduce((a, inv) => a + (inv.spec || EQUIPMENT.inverters[inv.typeKey]).acPower, 0);
        if(totalACCapacity === 0) totalACCapacity = APP.inverter.acPower;
        const dcAcRatio = dcCapacity / totalACCapacity;

        if(dcAcRatio > 1.3) {
            recommendations.push(`DC/AC ratio of ${dcAcRatio.toFixed(2)} is aggressive. ${dcAcRatio > 1.5 ? 'Significant' : 'Moderate'} clipping expected.`);
        } else if(dcAcRatio < 1.1) {
            recommendations.push(`DC/AC ratio of ${dcAcRatio.toFixed(2)} is conservative. Consider adding panels or downsizing inverter.`);
        }

        // Clipping risk warning when shade data is missing
        if(!APP.hasShade && dcAcRatio > 1.0) {
            const avgPanelTsrf = APP.panelStats.length > 0 ? APP.panelStats.reduce((a,p) => a + (p.tsrf || 0.8), 0) / APP.panelStats.length : 0.8;
            const summerPeakTSRF = APP.getSeasonalTSRF(avgPanelTsrf, 172);
            const summerPeakDC = APP.geo.length * APP.panel.watts * summerPeakTSRF;
            const summerDcAcRatio = summerPeakDC / totalACCapacity;

            issues.push({
                icon: '\u26A0\uFE0F',
                title: 'Clipping Risk (No Shade Data)',
                desc: `Shade profiles not loaded — using seasonal TSRF decomposition. ` +
                      `Nameplate DC/AC: ${dcAcRatio.toFixed(2)}. ` +
                      `Estimated summer peak DC/AC: ${summerDcAcRatio.toFixed(2)} ` +
                      `(summer TSRF ~${(summerPeakTSRF * 100).toFixed(0)}% vs annual avg ${(avgPanelTsrf * 100).toFixed(0)}%). ` +
                      `${summerDcAcRatio > 1.0 ? 'Clipping IS expected in summer months.' : 'Clipping unlikely despite ratio > 1.0.'} ` +
                      `Load EVIA shade data for precise clipping analysis.`
            });

            if(summerDcAcRatio > 1.0) {
                const estClipPct = ((summerDcAcRatio - 1.0) / summerDcAcRatio * 100);
                recommendations.push(
                    `Summer clipping estimated at ~${estClipPct.toFixed(1)}% of peak capacity. ` +
                    `Load EVIA shade data for this project to confirm exact clipping losses. ` +
                    `If confirmed, consider battery storage or a larger inverter to absorb DC excess.`
                );
            }
        }

        // Battery analysis
        const hasBattery = APP.batteryState.some(b => b !== null);
        const eb = APP.energyBalance;
        if(hasBattery) {
            const savedFromClip = eb.batteryCharged;
            if(savedFromClip > 0) {
                issues.push({
                    icon: '\uD83D\uDD0B',
                    title: 'Battery Absorption',
                    desc: `Battery absorbed ${Math.round(savedFromClip)} kWh that would otherwise be clipped or curtailed. Round-trip losses: ${Math.round(eb.batteryLosses)} kWh.`
                });
            }
            const totalCapWh = APP.batteryState.filter(b=>b).reduce((a,b) => a + b.config.totalCapacityWh, 0);
            const cycles = totalCapWh > 0 ? (eb.batteryCharged * 1000 / totalCapWh) : 0;
            if(cycles < 100) {
                recommendations.push(`Battery cycling is low (${cycles.toFixed(0)} cycles/yr). Battery may be oversized for this system.`);
            } else if(cycles > 300) {
                recommendations.push(`Battery cycling is high (${cycles.toFixed(0)} cycles/yr). Consider adding expansion packs to reduce depth-of-discharge.`);
            }
        }

        // Home consumption analysis
        if(APP.homeConsumption.enabled && eb.totalProduction > 0) {
            const selfPct = (eb.selfConsumed / eb.totalProduction * 100);
            issues.push({
                icon: '\uD83C\uDFE0',
                title: 'Energy Balance',
                desc: `Self-consumption: ${selfPct.toFixed(1)}%. Grid export: ${Math.round(eb.gridExport)} kWh. Grid import: ${Math.round(eb.gridImport)} kWh.`
            });
            if(selfPct < 30 && !hasBattery) {
                recommendations.push('Self-consumption is low. Adding battery storage would capture more solar production for home use.');
            }
            if(eb.curtailed > 50) {
                recommendations.push(`Export limit curtailed ${eb.curtailed.toFixed(0)} kWh. ${hasBattery ? 'Consider adding expansion packs' : 'Adding battery storage'} to capture this energy.`);
            }
        }

        // ─── Steps 5A-F: Battery Analytics in AI Analysis ───
        const ba = APP.batteryAnalytics;
        if(hasBattery && ba) {
            // 5A. Grid Independence Score
            issues.push({
                icon: '🌐',
                title: 'Grid Independence',
                desc: `${ba.gridIndependencePct.toFixed(1)}% of home load met by solar + battery. Grid provides ${Math.round(eb.gridImport).toLocaleString()} kWh/yr (${(100 - ba.gridIndependencePct).toFixed(1)}%).`
            });

            // 5B. Overnight Coverage Recommendation
            const ov = ba.overnight;
            const ovCovPct = ov.nightsTotal > 0 ? (ov.nightsCovered / ov.nightsTotal * 100) : 0;
            const totalCapKwh = APP.batteryState.filter(b=>b).reduce((a,b) => a + b.config.totalCapacityWh, 0) / 1000;
            const usableKwh = totalCapKwh * (1 - APP.homeConsumption.backupReservePct / 100);
            const avgNightLoad = ov.nightsTotal > 0 ? (ov.totalLoadKwh / ov.nightsTotal) : 0;
            if(ovCovPct < 80) {
                const shortfall = avgNightLoad - usableKwh;
                const expansionsNeeded = shortfall > 0 ? Math.ceil(shortfall / 13.5) : 0;
                recommendations.push(`Battery covers only ${ovCovPct.toFixed(0)}% of nights (${ov.nightsCovered}/${ov.nightsTotal}). Avg overnight load is ${avgNightLoad.toFixed(1)} kWh vs ${usableKwh.toFixed(1)} kWh usable capacity.${expansionsNeeded > 0 ? ` Consider adding ${expansionsNeeded} expansion pack(s) (~${(expansionsNeeded * 13.5).toFixed(0)} kWh) for full overnight coverage.` : ''}`);
            } else {
                issues.push({
                    icon: '🌙',
                    title: 'Overnight Coverage',
                    desc: `Battery covers ${ovCovPct.toFixed(0)}% of nights (${ov.nightsCovered}/${ov.nightsTotal}). Avg overnight load: ${avgNightLoad.toFixed(1)} kWh. Summer: ${ov.summerCovered}/${ov.summerTotal}, Winter: ${ov.winterCovered}/${ov.winterTotal}.`
                });
            }

            // 5C. Battery Sizing Recommendation
            const totalCapWh2 = APP.batteryState.filter(b=>b).reduce((a,b) => a + b.config.totalCapacityWh, 0);
            const annualCycles = totalCapWh2 > 0 ? (eb.batteryCharged * 1000 / totalCapWh2) : 0;
            if(annualCycles < 100 && eb.gridImport < 500) {
                recommendations.push(`Battery appears oversized: only ${annualCycles.toFixed(0)} cycles/yr with minimal grid import (${Math.round(eb.gridImport)} kWh). System is well-covered but battery utilization is low.`);
            } else if(annualCycles > 250 && eb.gridImport > eb.totalProduction * 0.3) {
                recommendations.push(`Battery appears undersized: ${annualCycles.toFixed(0)} cycles/yr with ${Math.round(eb.gridImport)} kWh grid import (${(eb.gridImport / (eb.selfConsumed + eb.gridImport) * 100).toFixed(0)}% of load). Consider expansion packs to increase capacity.`);
            } else {
                issues.push({
                    icon: '✅',
                    title: 'Battery Sizing',
                    desc: `Battery well-sized at ${annualCycles.toFixed(0)} cycles/yr. Grid import: ${Math.round(eb.gridImport)} kWh (${(eb.gridImport / (eb.selfConsumed + eb.gridImport) * 100).toFixed(0)}% of load).`
                });
            }

            // 5D. Degradation Projection
            const yr5 = ba.degradation[4]; // index 4 = year 5
            const yr10 = ba.degradation[9]; // index 9 = year 10
            const annCyc = ba.degradation[0].estCycles;
            const lifetimeCycles = annCyc * 25; // 25-year system life
            issues.push({
                icon: '📉',
                title: 'Degradation Projection (LFP)',
                desc: `Year 5: ${yr5.capacityKwh.toFixed(1)} kWh (${yr5.retainedPct.toFixed(1)}%). Year 10: ${yr10.capacityKwh.toFixed(1)} kWh (${yr10.retainedPct.toFixed(1)}%). At ${annCyc.toFixed(0)} cycles/yr → ~${lifetimeCycles.toFixed(0)} lifetime cycles (PW3 rated ~10,000). ${yr10.warrantyOk ? 'Within warranty.' : '⚠️ Below 70% warranty threshold at year 10.'}`
            });

            // 5E. Economic Optimization
            const econ = ba.economic;
            issues.push({
                icon: '💰',
                title: 'Economic Value',
                desc: `Battery avoids $${econ.annualSavings.toFixed(0)}/yr in peak grid imports at configured rates. Without battery, grid import would be ${econ.withoutBatteryGridKwh.toFixed(0)} kWh vs ${Math.round(eb.gridImport)} kWh with battery (${(econ.withoutBatteryGridKwh - eb.gridImport).toFixed(0)} kWh saved).`
            });

            // 5F. CO Compliance Note
            issues.push({
                icon: '⚖️',
                title: 'CO/Xcel Compliance',
                desc: `System configured per CO/Xcel rules: battery charges from PV only (${eb.batteryExportedToGrid < 0.01 ? '✓ verified' : '⚠️ VIOLATION'}), no grid export from battery. ${eb.batteryExportedToGrid < 0.01 ? 'All compliance checks passed.' : `Battery exported ${eb.batteryExportedToGrid.toFixed(1)} kWh to grid — investigate dispatch logic.`}`
            });
        }

        // HTML
        let html = '';

        if(issues.length > 0) {
            html += `
                <div class="recommendation-card">
                    <div class="rec-header">\uD83D\uDD0D Issues Detected</div>
                    <div class="rec-body">
                        ${issues.map(i => `
                            <div class="issue-item">
                                <span class="issue-icon">${i.icon}</span>
                                <div>
                                    <strong>${i.title}</strong><br>
                                    <span style="color:#94a3b8;">${i.desc}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        if(recommendations.length > 0) {
            html += `
                <div class="recommendation-card" style="border-color:var(--success); background:rgba(52,211,153,0.1);">
                    <div class="rec-header" style="color:var(--success);">AI Recommendations</div>
                    <div class="rec-body">
                        ${recommendations.map(r => `<div style="margin-bottom:8px;">\u2022 ${r}</div>`).join('')}
                    </div>
                </div>
            `;
        }

        html += `
            <div class="recommendation-card">
                <div class="rec-header">Optimal Layout Strategy</div>
                <div class="rec-body">
                    <p>Based on your shade analysis, here's the recommended approach:</p>
                    <ol style="margin:10px 0; padding-left:20px;">
                        <li style="margin-bottom:6px;"><strong>Group by TSRF:</strong> String panels with similar shade profiles to minimize bypass diode activation</li>
                        <li style="margin-bottom:6px;"><strong>Isolate low performers:</strong> Use microinverters for heavily shaded panels to avoid dragging string current down</li>
                        <li style="margin-bottom:6px;"><strong>String sizing:</strong> ${Math.floor(APP.inverter.mpptMax / (APP.panel.voc * 1.1))}-${Math.floor(APP.inverter.mpptMax / APP.panel.voc)} panels per string for your equipment</li>
                        <li style="margin-bottom:6px;"><strong>Bypass diodes:</strong> ${APP.panel.bypassDiodes} per panel (${APP.panel.cellsPerSubstring} cells/substring). Shade on 1/${APP.panel.bypassDiodes} of a panel activates 1 diode.</li>
                    </ol>
                    <button class="btn-sm btn-purple" onclick="APP.autoString()" style="margin-top:10px;">Apply Auto-String</button>
                </div>
            </div>
        `;

        // === MISMATCH OPTIMIZER ===
        if(APP.strings.length > 0 && APP.panelStats.length > 0) {
            const optimizer = APP.runMismatchOptimizer();
            if(optimizer) {
                html += `
                    <div class="recommendation-card" style="border-color:var(--accent); background:rgba(56,189,248,0.1);">
                        <div class="rec-header" style="color:var(--accent);">⚡ Mismatch Optimizer</div>
                        <div class="rec-body">
                            <p style="margin-bottom:10px;">Current strings analyzed for TSRF variance (lower is better):</p>
                            ${optimizer.currentAnalysis}
                            ${optimizer.hasImprovement ? `
                                <div style="margin-top:12px; padding-top:10px; border-top:1px solid rgba(56,189,248,0.3);">
                                    <strong style="color:var(--accent);">Optimized Layout Recommendation:</strong>
                                    <p style="margin:6px 0;">Re-grouping panels by similar TSRF could reduce mismatch loss from <strong>${optimizer.currentLoss.toFixed(1)}%</strong> to ~<strong>${optimizer.proposedLoss.toFixed(1)}%</strong> (${optimizer.improvement.toFixed(1)}% improvement).</p>
                                    ${optimizer.proposedLayout}
                                    <button class="btn-sm btn-purple" onclick="APP.applyOptimizedStrings()" style="margin-top:10px;">Apply Optimized Layout</button>
                                </div>
                            ` : `<p style="margin-top:8px; color:var(--success);">✓ Current string layout is near-optimal. TSRF variance within strings is minimal.</p>`}
                        </div>
                    </div>
                `;
            }
        }

        container.innerHTML = html;
    },

    // ============== MISMATCH OPTIMIZER ==============
    runMismatchOptimizer: () => {
        if(APP.strings.length === 0 || APP.panelStats.length === 0) return null;

        // Analyze current strings
        const currentStringStats = APP.strings.map((str, idx) => {
            const tsrfs = str.panels.map(pIdx => APP.panelStats[pIdx]?.tsrf || 0);
            const avg = tsrfs.reduce((a,b) => a+b, 0) / tsrfs.length;
            const min = Math.min(...tsrfs);
            const max = Math.max(...tsrfs);
            const variance = tsrfs.reduce((a,v) => a + Math.pow(v - avg, 2), 0) / tsrfs.length;
            return { idx, panels: str.panels, avg, min, max, variance, spread: max - min };
        });

        const currentAnalysisHtml = `<div style="font-size:11px;">
            ${currentStringStats.map(s => {
                const qualColor = s.spread > 0.2 ? 'var(--err)' : s.spread > 0.1 ? 'var(--warn)' : 'var(--success)';
                return `<div style="display:flex; justify-content:space-between; padding:3px 0; border-bottom:1px solid rgba(255,255,255,0.05);">
                    <span>S${s.idx+1} (${s.panels.length}p)</span>
                    <span>TSRF: ${(s.min*100).toFixed(0)}-${(s.max*100).toFixed(0)}%</span>
                    <span style="color:${qualColor};">Spread: ${(s.spread*100).toFixed(1)}%</span>
                </div>`;
            }).join('')}
        </div>`;

        // Compute current total variance
        const currentTotalVariance = currentStringStats.reduce((a,s) => a + s.variance * s.panels.length, 0) / APP.panelStats.length;

        // Build optimized layout: sort all strung panels by TSRF and group sequentially
        const allStrungPanels = [];
        APP.strings.forEach(str => { str.panels.forEach(pIdx => allStrungPanels.push(pIdx)); });
        allStrungPanels.sort((a,b) => (APP.panelStats[b]?.tsrf || 0) - (APP.panelStats[a]?.tsrf || 0));

        // Distribute into strings of same sizes as current
        const stringSizes = APP.strings.map(s => s.panels.length);
        const proposedStrings = [];
        let offset = 0;
        stringSizes.forEach(size => {
            proposedStrings.push(allStrungPanels.slice(offset, offset + size));
            offset += size;
        });

        // Compute proposed variance
        let proposedTotalVariance = 0;
        const proposedStats = proposedStrings.map((panels, idx) => {
            const tsrfs = panels.map(pIdx => APP.panelStats[pIdx]?.tsrf || 0);
            const avg = tsrfs.reduce((a,b) => a+b, 0) / tsrfs.length;
            const min = Math.min(...tsrfs);
            const max = Math.max(...tsrfs);
            const variance = tsrfs.reduce((a,v) => a + Math.pow(v - avg, 2), 0) / tsrfs.length;
            proposedTotalVariance += variance * panels.length;
            return { idx, panels, avg, min, max, variance, spread: max - min };
        });
        proposedTotalVariance /= APP.panelStats.length;

        // Estimate mismatch loss reduction
        const indepTotal = APP.panelTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const stringTotal = APP.stringTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const currentLoss = indepTotal > 0 ? ((indepTotal - stringTotal) / indepTotal * 100) : 0;

        // Rough estimate: lower variance => proportionally lower mismatch loss
        const varianceReduction = currentTotalVariance > 0 ? (1 - proposedTotalVariance / currentTotalVariance) : 0;
        const proposedLoss = currentLoss * (1 - varianceReduction * 0.7); // conservative factor
        const improvement = currentLoss - proposedLoss;
        const hasImprovement = improvement > 0.5; // only suggest if >0.5% improvement

        const proposedLayoutHtml = `<div style="font-size:11px; margin-top:8px;">
            ${proposedStats.map(s => {
                const qualColor = s.spread > 0.2 ? 'var(--err)' : s.spread > 0.1 ? 'var(--warn)' : 'var(--success)';
                return `<div style="display:flex; justify-content:space-between; padding:3px 0; border-bottom:1px solid rgba(255,255,255,0.05);">
                    <span>S${s.idx+1} (${s.panels.length}p): P${s.panels.map(p => p+1).join(',')}</span>
                    <span style="color:${qualColor};">TSRF: ${(s.min*100).toFixed(0)}-${(s.max*100).toFixed(0)}%</span>
                </div>`;
            }).join('')}
        </div>`;

        // Store proposed layout for apply
        APP._proposedStrings = proposedStrings;

        return {
            currentAnalysis: currentAnalysisHtml,
            proposedLayout: proposedLayoutHtml,
            currentLoss,
            proposedLoss,
            improvement,
            hasImprovement
        };
    },

    applyOptimizedStrings: () => {
        if(!APP._proposedStrings || APP._proposedStrings.length === 0) return;

        // Clear current strings
        APP.strings = [];
        APP.panelToString = {};
        APP.stringToInverter = {};
        APP.inverters.forEach(inv => { inv.strings = []; });

        // Apply proposed strings
        APP._proposedStrings.forEach((panels, idx) => {
            APP.strings.push({
                panels: [...panels],
                color: STRING_COLORS[idx % STRING_COLORS.length]
            });
            panels.forEach(pIdx => { APP.panelToString[pIdx] = idx; });
        });

        APP.log(`Applied optimized string layout: ${APP.strings.length} strings`, 'ok');
        APP.recalcStrings();
        APP.renderStringView();
        APP.renderInverterConfig();
        APP.refreshModels();
    },

    // ============== TABS ==============
    tab: (id, btn) => {
        document.querySelectorAll('.view-pane').forEach(e=>e.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(e=>e.classList.remove('active'));
        document.getElementById(`view-${id}`).classList.add('active');
        btn.classList.add('active');

        if(id === 'map') APP.renderMap();
        if(id === 'string') APP.renderStringView();
        if(id === 'ts') APP.renderTimeseries();
        if(id === 'inverter') APP.renderInverterView();
        if(id === 'battery') APP.renderBatteryView();
        if(id === 'scenarios') APP.renderScenarioComparison();
    },

    // ============== EXPORT ==============
    exportConfig: () => {
        const indepTotal = APP.panelTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const stringTotal = APP.stringTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);

        const config = {
            equipment: {
                panel: document.getElementById('selPanel').value,
                inverter: document.getElementById('selInverter').value,
                ess: document.getElementById('selESS').value
            },
            siteConditions: {
                tempMin: parseFloat(document.getElementById('tempMin').value),
                tempMax: parseFloat(document.getElementById('tempMax').value),
                clippingThreshold: APP.clippingThreshold
            },
            strings: APP.strings.map((s, i) => ({
                id: i + 1,
                panels: s.panels.map(p => p + 1),
                electrical: s.electrical,
                inverter: APP.stringToInverter[i] !== undefined ? APP.inverters[APP.stringToInverter[i]].name : 'Unassigned'
            })),
            inverters: APP.inverters.map(inv => ({
                name: inv.name,
                type: (inv.spec || EQUIPMENT.inverters[inv.typeKey]).name,
                strings: inv.strings.map(s => s + 1)
            })),
            production: {
                independentAnnual: Math.round(indepTotal),
                stringLevelAnnual: Math.round(stringTotal),
                eagleViewAnnual: Math.round(APP.eagleViewProduction.annual),
                mismatchLoss: indepTotal > 0 ? ((indepTotal - stringTotal) / indepTotal * 100).toFixed(1) + '%' : 'N/A',
                clippingLoss: APP.clippingLoss.toFixed(1) + '%',
                clippingEvents: APP.clippingEvents.length
            },
            homeConsumption: {
                enabled: APP.homeConsumption.enabled,
                annualKwh: APP.homeConsumption.annualKwh,
                priorityMode: APP.homeConsumption.priorityMode,
                backupReservePct: APP.homeConsumption.backupReservePct
            },
            utilityRates: APP.utilityRates,
            batteryConfig: APP.batteryConfig.filter(b => b).map(b => ({
                essKey: b.essKey,
                expansions: b.expansions,
                totalCapacityKwh: b.totalCapacityWh / 1000,
                dcChargeRateKw: b.totalDcChargeW / 1000
            })),
            energyBalance: APP.energyBalance,
            exportLimitKw: APP.exportLimitW / 1000,
            batteryAnalytics: APP.batteryAnalytics ? {
                gridIndependencePct: APP.batteryAnalytics.gridIndependencePct,
                overnightCoverage: APP.batteryAnalytics.overnight ? `${APP.batteryAnalytics.overnight.nightsCovered}/${APP.batteryAnalytics.overnight.nightsTotal}` : null,
                annualSavings: APP.batteryAnalytics.economic?.annualSavings,
                roundTripEfficiency: APP.batteryAnalytics.efficiency?.effectiveRoundTrip,
                coCompliant: APP.energyBalance.batteryExportedToGrid < 0.01
            } : null
        };

        const blob = new Blob([JSON.stringify(config, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'solar-surveyor-v11-config.json';
        a.click();
        URL.revokeObjectURL(url);
        APP.log('Configuration exported', 'ok');
    },

    exportCSV: () => {
        if(!APP.panelStats.length) { APP.log("Run analysis first", 'warn'); return; }

        // Build per-panel string yields same as prod table
        const panelStringYields = new Array(APP.panelStats.length).fill(0);
        APP.strings.forEach((str, sIdx) => {
            if(!APP.stringTimeseries[sIdx]) return;
            const stringAnnualKwh = Array.from(APP.stringTimeseries[sIdx]).reduce((a,b) => a+b, 0) / 2000;
            let totalTsrf = 0;
            str.panels.forEach(pIdx => { totalTsrf += (APP.panelStats[pIdx]?.tsrf || 0.5); });
            str.panels.forEach(pIdx => {
                panelStringYields[pIdx] = stringAnnualKwh * ((APP.panelStats[pIdx]?.tsrf || 0.5) / (totalTsrf || 1));
            });
        });

        let csv = 'Panel,String,Avg Irradiance (W/m2),TSRF (%),Independent kWh,String kWh,Mismatch Loss (%),EagleView SAV (%),Status\n';
        APP.panelStats.forEach((p, idx) => {
            const sIdx = APP.panelToString[p.id - 1];
            const sName = sIdx !== undefined ? `S${sIdx+1}` : '';
            const evSAV = APP.eagleViewProduction.panelSAV[idx];
            const strYield = panelStringYields[idx] || 0;
            const mismatch = p.yield > 0 && strYield > 0 ? ((p.yield - strYield) / p.yield * 100) : 0;
            const status = p.tsrf < 0.5 ? 'Poor' : p.tsrf < 0.7 ? 'Low' : 'OK';
            csv += `P${p.id},${sName},${(p.irr/1000).toFixed(0)},${(p.tsrf*100).toFixed(1)},${Math.round(p.yield)},${strYield > 0 ? Math.round(strYield) : ''},${strYield > 0 ? mismatch.toFixed(1) : ''},${evSAV !== undefined ? (evSAV*100).toFixed(1) : ''},${status}\n`;
        });

        // Totals
        const indepTotal = APP.panelStats.reduce((a,p) => a + p.yield, 0);
        const strTotal = panelStringYields.reduce((a,b) => a+b, 0);
        csv += `\nTotals,,,,${Math.round(indepTotal)},${strTotal > 0 ? Math.round(strTotal) : ''},${indepTotal > 0 && strTotal > 0 ? ((indepTotal-strTotal)/indepTotal*100).toFixed(1) : ''},,\n`;
        csv += `EagleView Annual,,,,${Math.round(APP.eagleViewProduction.annual)},,,,\n`;

        // String summary
        csv += '\n\nString Summary\nString,Panels,Voc Cold (V),Vmp (V),Power (kW),Inverter\n';
        APP.strings.forEach((str, i) => {
            const e = str.electrical || APP.calculateStringElectrical(str.panels);
            const invIdx = APP.stringToInverter[i];
            const invName = invIdx !== undefined ? APP.inverters[invIdx].name : 'Unassigned';
            csv += `S${i+1},${str.panels.length},${e.vocCold.toFixed(1)},${e.vmp.toFixed(1)},${(e.power/1000).toFixed(2)},${invName}\n`;
        });

        // Inverter summary
        csv += '\n\nInverter Summary\nInverter,Type,AC Rating (kW),Strings,DC In (kWh),AC Out (kWh),Clipped (kWh),Peak DC (kW),Max Clip %\n';
        APP.inverters.forEach((inv, idx) => {
            const spec = inv.spec || EQUIPMENT.inverters[inv.typeKey];
            const ts = APP.inverterTimeseries[idx];
            let totalDC=0, totalAC=0, totalClip=0, peakDC=0;
            if(ts) ts.forEach(t => { totalDC += t.dcInput; totalAC += t.acOutput; totalClip += t.clippedW; peakDC = Math.max(peakDC, t.dcInput); });
            const maxClipPct = spec.acPower > 0 ? ((peakDC / spec.acPower) * 100).toFixed(1) : '0';
            csv += `${inv.name},${spec.name},${(spec.acPower/1000).toFixed(1)},${inv.strings.map(s=>'S'+(s+1)).join(';')},${(totalDC/2000).toFixed(0)},${(totalAC/2000).toFixed(0)},${(totalClip/2000).toFixed(1)},${(peakDC/1000).toFixed(2)},${maxClipPct}%\n`;
        });

        // Per-inverter clipping events
        if(APP.clippingEvents.length > 0) {
            APP.inverters.forEach((inv, idx) => {
                const invEvents = APP.clippingEvents.filter(e => e.inverterId === idx);
                if(invEvents.length === 0) return;
                csv += `\n\nClipping Events - ${inv.name} (${(inv.spec || EQUIPMENT.inverters[inv.typeKey]).name})\nDate,Start,End,Duration (min),Peak Clip (kW),Total Clipped (kWh)\n`;
                invEvents.forEach(e => {
                    csv += `${e.date},${e.startTime},${e.endTime},${e.durationMin},${(e.peakClipW/1000).toFixed(3)},${e.totalClipWh.toFixed(3)}\n`;
                });
                const totalHrs = invEvents.reduce((a,e) => a + e.durationMin, 0) / 60;
                const totalKwh = invEvents.reduce((a,e) => a + e.totalClipWh, 0);
                csv += `Total,${invEvents.length} events,,${(totalHrs * 60).toFixed(0)} min,,${totalKwh.toFixed(1)} kWh\n`;
            });
        }

        // Energy Balance section
        const eb = APP.energyBalance;
        if(eb.totalProduction > 0 && (APP.homeConsumption.enabled || APP.batteryState.some(b => b !== null))) {
            csv += '\n\nEnergy Balance\nMetric,Value\n';
            csv += `Total Production (kWh),${Math.round(eb.totalProduction)}\n`;
            csv += `Self-Consumed (kWh),${Math.round(eb.selfConsumed)}\n`;
            csv += `Self-Consumption Rate (%),${(eb.selfConsumed / eb.totalProduction * 100).toFixed(1)}\n`;
            csv += `Grid Export (kWh),${Math.round(eb.gridExport)}\n`;
            csv += `Grid Import (kWh),${Math.round(eb.gridImport)}\n`;
            csv += `Battery Charged (kWh),${Math.round(eb.batteryCharged)}\n`;
            csv += `Battery Discharged (kWh),${Math.round(eb.batteryDischarged)}\n`;
            csv += `Battery Round-Trip Loss (kWh),${Math.round(eb.batteryLosses)}\n`;
            csv += `Inverter Clipping Loss (kWh),${eb.clipped.toFixed(1)}\n`;
            csv += `Export Curtailed (kWh),${eb.curtailed.toFixed(1)}\n`;
            csv += `Home Consumption (kWh/yr),${APP.homeConsumption.enabled ? Math.round(APP.homeConsumption.annualKwh) : 'N/A'}\n`;
            csv += `Export Limit (kW),${APP.exportLimitW > 0 ? (APP.exportLimitW/1000).toFixed(1) : 'Unlimited'}\n`;
            csv += `Priority Mode,${APP.homeConsumption.priorityMode}\n`;
        }

        // Battery Config section
        if(APP.batteryState.some(b => b !== null)) {
            csv += '\n\nBattery Configuration\nInverter,ESS Type,Expansions,Capacity (kWh),DC Charge Rate (kW),Charged (kWh),Discharged (kWh)\n';
            APP.batteryState.forEach((bState, invIdx) => {
                if(!bState) return;
                const inv = APP.inverters[invIdx];
                const cfg = bState.config;
                const chg = Array.from(bState.chargeW).reduce((a,b) => a+b, 0) * 0.5 / 1000;
                const dis = Array.from(bState.dischargeW).reduce((a,b) => a+b, 0) * 0.5 / 1000;
                csv += `${inv.name},${cfg.essKey},${cfg.expansions},${(cfg.totalCapacityWh/1000).toFixed(1)},${(cfg.totalDcChargeW/1000).toFixed(0)},${Math.round(chg)},${Math.round(dis)}\n`;
            });
        }

        // Battery Analytics (from computeBatteryAnalytics)
        const ba = APP.batteryAnalytics;
        if(ba) {
            csv += '\n\nBattery Analytics Summary\nMetric,Value\n';
            csv += `Grid Independence (%),${ba.gridIndependencePct.toFixed(1)}\n`;
            csv += `Overnight Nights Covered,${ba.overnight.nightsCovered}/${ba.overnight.nightsTotal}\n`;
            csv += `Overnight Coverage (%),${(ba.overnight.nightsTotal > 0 ? ba.overnight.nightsCovered / ba.overnight.nightsTotal * 100 : 0).toFixed(1)}\n`;
            csv += `Avg Overnight Load (kWh),${(ba.overnight.totalLoadKwh / Math.max(1, ba.overnight.nightsTotal)).toFixed(1)}\n`;
            csv += `Overnight Grid Import (kWh/yr),${ba.overnight.totalGridKwh.toFixed(0)}\n`;
            csv += `Round-Trip Efficiency (%),${(ba.efficiency.effectiveRoundTrip * 100).toFixed(1)}\n`;
            csv += `Total Battery Losses (kWh),${ba.efficiency.totalLossKwh.toFixed(0)}\n`;
            csv += `Annual Savings ($),${ba.economic.annualSavings.toFixed(2)}\n`;
            csv += `Grid kWh Without Battery,${ba.economic.withoutBatteryGridKwh.toFixed(0)}\n`;
            csv += `CO Compliant,${eb.batteryExportedToGrid < 0.01 ? 'Yes' : 'NO - VIOLATION'}\n`;
            csv += `Backup Reserve (%),${APP.homeConsumption.backupReservePct}\n`;
            csv += `Utility Rate Standard ($/kWh),${APP.utilityRates.standard}\n`;
            csv += `Utility Rate Peak ($/kWh),${APP.utilityRates.peak}\n`;
            csv += `Utility Rate Off-Peak ($/kWh),${APP.utilityRates.offPeak}\n`;

            csv += '\n\nMonthly Battery Performance\nMonth,Charged (kWh),Discharged (kWh),Cycles,Avg SoC (%),Grid Import (kWh),Self-Consumed (%),Production (kWh)\n';
            const mNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            ba.monthly.forEach((m, i) => {
                csv += `${mNames[i]},${m.charged.toFixed(0)},${m.discharged.toFixed(0)},${m.cycles.toFixed(1)},${m.avgSocPct.toFixed(0)},${m.gridImport.toFixed(0)},${m.selfConsumedPct.toFixed(0)},${m.production.toFixed(0)}\n`;
            });

            csv += '\n\n10-Year Degradation Projection\nYear,Capacity (kWh),Retained (%),Est Cycles/Yr,Cumulative Cycles,Warranty OK\n';
            ba.degradation.forEach(d => {
                csv += `${d.year},${d.capacityKwh.toFixed(1)},${d.retainedPct.toFixed(1)},${d.estCycles.toFixed(0)},${d.cumCycles.toFixed(0)},${d.warrantyOk ? 'Yes' : 'No'}\n`;
            });
        }

        const blob = new Blob([csv], {type: 'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'solar-surveyor-v11-report.csv'; a.click();
        URL.revokeObjectURL(url);
        APP.log('CSV exported for Google Sheets', 'ok');
    },

    generateReport: () => {
        if(!APP.panelStats.length) { APP.log("Run analysis first", 'warn'); return; }
        APP.log('Generating PDF report...', 'ok');

        const indepTotal = APP.panelTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const stringTotal = APP.stringTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b)=>a+b,0)/2000, 0);
        const evTotal = APP.eagleViewProduction.annual;
        const mismatchLoss = indepTotal > 0 ? ((indepTotal - stringTotal) / indepTotal * 100) : 0;
        const dcCap = (APP.geo.length * APP.panel.watts) / 1000;

        // Build panel table rows
        const panelStringYields = new Array(APP.panelStats.length).fill(0);
        APP.strings.forEach((str, sIdx) => {
            if(!APP.stringTimeseries[sIdx]) return;
            const sKwh = Array.from(APP.stringTimeseries[sIdx]).reduce((a,b) => a+b, 0) / 2000;
            let tTsrf = 0;
            str.panels.forEach(pIdx => { tTsrf += (APP.panelStats[pIdx]?.tsrf || 0.5); });
            str.panels.forEach(pIdx => { panelStringYields[pIdx] = sKwh * ((APP.panelStats[pIdx]?.tsrf || 0.5) / (tTsrf || 1)); });
        });

        let panelRows = '';
        APP.panelStats.forEach((p, idx) => {
            const sIdx = APP.panelToString[p.id - 1];
            const sName = sIdx !== undefined ? `S${sIdx+1}` : '-';
            const strY = panelStringYields[idx] || 0;
            const mm = p.yield > 0 && strY > 0 ? ((p.yield - strY) / p.yield * 100).toFixed(1) + '%' : '-';
            const status = p.tsrf < 0.5 ? '⚠ Poor' : p.tsrf < 0.7 ? '⚡ Low' : '✓ OK';
            panelRows += `<tr><td>P${p.id}</td><td>${sName}</td><td>${(p.tsrf*100).toFixed(1)}%</td><td>${Math.round(p.yield)}</td><td>${strY > 0 ? Math.round(strY) : '-'}</td><td>${mm}</td><td>${status}</td></tr>`;
        });

        let stringRows = '';
        APP.strings.forEach((str, i) => {
            const e = str.electrical || APP.calculateStringElectrical(str.panels);
            const invIdx = APP.stringToInverter[i];
            const invName = invIdx !== undefined ? APP.inverters[invIdx].name : 'Unassigned';
            stringRows += `<tr><td>S${i+1}</td><td>${str.panels.length}</td><td>${e.vocCold.toFixed(1)}V</td><td>${(e.power/1000).toFixed(2)} kW</td><td>${invName}</td></tr>`;
        });

        let invRows = '';
        APP.inverters.forEach((inv, idx) => {
            const spec = inv.spec || EQUIPMENT.inverters[inv.typeKey];
            const ts = APP.inverterTimeseries[idx];
            let tDC=0, tAC=0, tClip=0;
            if(ts) ts.forEach(t => { tDC += t.dcInput; tAC += t.acOutput; tClip += t.clippedW; });
            invRows += `<tr><td>${inv.name}</td><td>${spec.name}</td><td>${(spec.acPower/1000).toFixed(1)} kW</td><td>${(tDC/2000).toFixed(0)} kWh</td><td>${(tAC/2000).toFixed(0)} kWh</td><td>${(tClip/2000).toFixed(1)} kWh</td></tr>`;
        });

        const clipEvents = APP.clippingEvents.length;
        const clipHrs = APP.clippingEvents.reduce((a,e) => a + e.durationMin, 0) / 60;

        const reportHtml = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Solar Surveyor V11 Report</title>
        <style>
            body { font-family: -apple-system, system-ui, sans-serif; max-width: 900px; margin: 0 auto; padding: 30px; color: #1e293b; }
            h1 { color: #0f172a; border-bottom: 3px solid #38bdf8; padding-bottom: 10px; }
            h2 { color: #334155; margin-top: 30px; border-bottom: 1px solid #e2e8f0; padding-bottom: 6px; }
            .summary-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
            .summary-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; text-align: center; }
            .summary-val { font-size: 24px; font-weight: 700; color: #0f172a; }
            .summary-lbl { font-size: 11px; color: #64748b; text-transform: uppercase; }
            table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 12px; }
            th { background: #f1f5f9; text-align: left; padding: 8px; border: 1px solid #e2e8f0; font-size: 11px; color: #475569; }
            td { padding: 6px 8px; border: 1px solid #e2e8f0; }
            tr:nth-child(even) { background: #fafafa; }
            .highlight { background: #dbeafe; font-weight: 600; }
            .footer { margin-top: 40px; padding-top: 15px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 10px; text-align: center; }
            @media print { body { max-width: none; } .no-print { display: none; } }
        </style></head><body>
        <h1>☀ Solar Surveyor V11 — Production Report</h1>
        <p>Generated: ${new Date().toLocaleString()} | Equipment: ${APP.panel.name} | Panels: ${APP.geo.length}</p>

        <h2>Production Summary — Triple Model Comparison</h2>
        <div class="summary-grid">
            <div class="summary-card"><div class="summary-val">${Math.round(indepTotal).toLocaleString()}</div><div class="summary-lbl">Independent kWh/yr (Model A)</div></div>
            <div class="summary-card"><div class="summary-val">${Math.round(stringTotal).toLocaleString()}</div><div class="summary-lbl">String-Level kWh/yr (Model B)</div></div>
            <div class="summary-card"><div class="summary-val">${evTotal > 0 ? Math.round(evTotal).toLocaleString() : 'N/A'}</div><div class="summary-lbl">EagleView kWh/yr (Model C)</div></div>
        </div>
        <div class="summary-grid">
            <div class="summary-card"><div class="summary-val">${dcCap.toFixed(1)} kW</div><div class="summary-lbl">DC Capacity</div></div>
            <div class="summary-card"><div class="summary-val">${mismatchLoss.toFixed(1)}%</div><div class="summary-lbl">Mismatch Loss</div></div>
            <div class="summary-card"><div class="summary-val">${APP.clippingLoss.toFixed(1)}%</div><div class="summary-lbl">Clipping Loss</div></div>
        </div>

        <h2>String Configuration</h2>
        <table><thead><tr><th>String</th><th>Panels</th><th>Voc Cold</th><th>Power</th><th>Inverter</th></tr></thead><tbody>${stringRows || '<tr><td colspan="5">No strings configured</td></tr>'}</tbody></table>

        <h2>Inverter Performance</h2>
        <table><thead><tr><th>Inverter</th><th>Type</th><th>AC Rating</th><th>DC Input</th><th>AC Output</th><th>Clipped</th></tr></thead><tbody>${invRows || '<tr><td colspan="6">No inverters configured</td></tr>'}</tbody></table>
        <p>Total clipping events: ${clipEvents} | Total duration: ${clipHrs.toFixed(0)} hours${APP.exportLimitW > 0 ? ` | Export limit: ${(APP.exportLimitW/1000).toFixed(1)} kW | Curtailed: ${APP.exportCurtailed.toFixed(1)} kWh` : ''}</p>

        ${(APP.homeConsumption.enabled || APP.batteryState.some(b => b !== null)) ? `
        <h2>Energy Balance & Battery</h2>
        <div class="summary-grid">
            <div class="summary-card"><div class="summary-val">${APP.energyBalance.totalProduction > 0 ? (APP.energyBalance.selfConsumed / APP.energyBalance.totalProduction * 100).toFixed(1) : '0'}%</div><div class="summary-lbl">Self-Consumption Rate</div></div>
            <div class="summary-card"><div class="summary-val">${Math.round(APP.energyBalance.gridExport).toLocaleString()}</div><div class="summary-lbl">Grid Export kWh</div></div>
            <div class="summary-card"><div class="summary-val">${Math.round(APP.energyBalance.gridImport).toLocaleString()}</div><div class="summary-lbl">Grid Import kWh</div></div>
        </div>
        ${APP.batteryState.some(b => b !== null) ? `
        <div class="summary-grid">
            <div class="summary-card"><div class="summary-val">${Math.round(APP.energyBalance.batteryCharged).toLocaleString()}</div><div class="summary-lbl">Battery Charged kWh</div></div>
            <div class="summary-card"><div class="summary-val">${Math.round(APP.energyBalance.batteryDischarged).toLocaleString()}</div><div class="summary-lbl">Battery Discharged kWh</div></div>
            <div class="summary-card"><div class="summary-val">${Math.round(APP.energyBalance.batteryLosses).toLocaleString()}</div><div class="summary-lbl">Round-Trip Losses kWh</div></div>
        </div>
        <p>Home Consumption: ${APP.homeConsumption.enabled ? Math.round(APP.homeConsumption.annualKwh).toLocaleString() + ' kWh/yr' : 'Not configured'} |
           Priority Mode: ${APP.homeConsumption.priorityMode} |
           Backup Reserve: ${APP.homeConsumption.backupReservePct}% |
           Total Lost (Clip + Curtail): ${(APP.energyBalance.clipped + APP.energyBalance.curtailed).toFixed(1)} kWh</p>
        ` : ''}
        ` : ''}

        ${APP.batteryAnalytics ? `
        <h2>Battery Analytics</h2>
        <div class="summary-grid">
            <div class="summary-card"><div class="summary-val">${APP.batteryAnalytics.gridIndependencePct.toFixed(1)}%</div><div class="summary-lbl">Grid Independence</div></div>
            <div class="summary-card"><div class="summary-val">${APP.batteryAnalytics.overnight.nightsCovered}/${APP.batteryAnalytics.overnight.nightsTotal}</div><div class="summary-lbl">Nights Covered</div></div>
            <div class="summary-card"><div class="summary-val">$${APP.batteryAnalytics.economic.annualSavings.toFixed(0)}</div><div class="summary-lbl">Annual Savings</div></div>
        </div>
        <div class="summary-grid">
            <div class="summary-card"><div class="summary-val">${(APP.batteryAnalytics.efficiency.effectiveRoundTrip * 100).toFixed(1)}%</div><div class="summary-lbl">Round-Trip Efficiency</div></div>
            <div class="summary-card"><div class="summary-val">${APP.batteryAnalytics.efficiency.totalLossKwh.toFixed(0)} kWh</div><div class="summary-lbl">Annual Losses</div></div>
            <div class="summary-card"><div class="summary-val">${APP.batteryAnalytics.degradation[9].capacityKwh.toFixed(1)} kWh</div><div class="summary-lbl">Year 10 Capacity</div></div>
        </div>
        <h3>Monthly Battery Performance</h3>
        <table><thead><tr><th>Month</th><th>Charged</th><th>Discharged</th><th>Cycles</th><th>Avg SoC</th><th>Grid Import</th><th>Self-Consumed</th></tr></thead><tbody>
        ${['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'].map((mn, i) => {
            const m = APP.batteryAnalytics.monthly[i];
            return '<tr><td>' + mn + '</td><td>' + m.charged.toFixed(0) + ' kWh</td><td>' + m.discharged.toFixed(0) + ' kWh</td><td>' + m.cycles.toFixed(1) + '</td><td>' + m.avgSocPct.toFixed(0) + '%</td><td>' + m.gridImport.toFixed(0) + ' kWh</td><td>' + m.selfConsumedPct.toFixed(0) + '%</td></tr>';
        }).join('')}
        </tbody></table>
        <h3>CO/Xcel Energy Compliance</h3>
        <p style="padding:8px; background:#f0fdf4; border:1px solid #86efac; border-radius:4px;">
            ✓ Battery charges from PV only (no grid charging) |
            ✓ Battery does not export to grid (powers house loads only) |
            Battery grid export: ${APP.energyBalance.batteryExportedToGrid.toFixed(2)} kWh
            ${APP.energyBalance.batteryExportedToGrid < 0.01 ? '— COMPLIANT' : '— ⚠️ VIOLATION DETECTED'}
        </p>
        <p>Utility Rates: Standard $${APP.utilityRates.standard.toFixed(2)}/kWh | Peak $${APP.utilityRates.peak.toFixed(2)}/kWh | Off-Peak $${APP.utilityRates.offPeak.toFixed(2)}/kWh</p>
        ` : ''}

        <h2>Panel Production Detail</h2>
        <table><thead><tr><th>Panel</th><th>String</th><th>TSRF</th><th>Indep kWh</th><th>String kWh</th><th>Mismatch</th><th>Status</th></tr></thead><tbody>${panelRows}</tbody></table>

        <div class="footer">
            Solar Surveyor V11 — String Mismatch & Inverter Clipping Suite<br>
            Panel: ${APP.panel.name} | Bypass Diodes: ${APP.panel.bypassDiodes} | Cells/Substring: ${APP.panel.cellsPerSubstring}
        </div>
        <script>window.onload = () => { window.print(); };<\/script>
        </body></html>`;

        const win = window.open('', '_blank');
        win.document.write(reportHtml);
        win.document.close();
        APP.log('PDF report opened in new window (use Print > Save as PDF)', 'ok');
    },

    // ============== SCENARIO MANAGER ==============
    promptSaveScenario: () => {
        const name = prompt('Scenario name:', `Scenario ${APP.scenarios.length + 1}`);
        if(name !== null && name.trim()) APP.saveScenario(name.trim());
    },

    saveScenario: (name) => {
        if(!APP.panelStats.length) { APP.log('Run analysis before saving a scenario', 'warn'); return null; }

        const indepTotal = APP.panelTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b) => a+b, 0) / 2000, 0);
        const stringTotal = APP.stringTimeseries.reduce((sum, s) => sum + Array.from(s).reduce((a,b) => a+b, 0) / 2000, 0);
        const eb = APP.energyBalance;
        const ba = APP.batteryAnalytics;
        const totalCapKwh = APP.batteryState.filter(b=>b).reduce((s,b) => s + b.config.totalCapacityWh, 0) / 1000;

        const scenario = {
            id: crypto.randomUUID(),
            name: name,
            createdAt: new Date().toISOString(),
            version: 'v11',
            design: {
                equipment: {
                    panel: document.getElementById('selPanel').value,
                    inverter: document.getElementById('selInverter').value,
                    ess: document.getElementById('selESS').value
                },
                siteConditions: {
                    tempMin: parseFloat(document.getElementById('tempMin').value),
                    tempMax: parseFloat(document.getElementById('tempMax').value),
                    clippingThreshold: APP.clippingThreshold,
                    exportLimitKw: APP.exportLimitW / 1000
                },
                strings: APP.strings.map(s => ({ panels: [...s.panels], color: s.color })),
                inverters: APP.inverters.map(inv => ({ typeKey: inv.typeKey, strings: [...inv.strings], name: inv.name })),
                stringToInverter: { ...APP.stringToInverter },
                batteryConfig: APP.batteryConfig.map(b => b ? { ...b } : null),
                homeConsumption: {
                    enabled: APP.homeConsumption.enabled,
                    annualKwh: APP.homeConsumption.annualKwh,
                    inputMethod: APP.homeConsumption.inputMethod,
                    monthlyKwh: APP.homeConsumption.monthlyKwh ? [...APP.homeConsumption.monthlyKwh] : null,
                    priorityMode: APP.homeConsumption.priorityMode,
                    backupReservePct: APP.homeConsumption.backupReservePct,
                    zipCode: APP.homeConsumption.zipCode,
                    sqFt: APP.homeConsumption.sqFt,
                    climateZone: APP.homeConsumption.climateZone
                },
                utilityRates: { ...APP.utilityRates }
            },
            results: {
                panelCount: APP.geo.length,
                dcCapacityKw: (APP.geo.length * APP.panel.watts) / 1000,
                avgTSRF: APP.panelStats.length > 0 ? APP.panelStats.reduce((a,p) => a + p.tsrf, 0) / APP.panelStats.length : 0,
                production: {
                    independentAnnual: Math.round(indepTotal),
                    stringLevelAnnual: Math.round(stringTotal),
                    eagleViewAnnual: Math.round(APP.eagleViewProduction.annual)
                },
                mismatchLossPct: indepTotal > 0 ? parseFloat(((indepTotal - stringTotal) / indepTotal * 100).toFixed(1)) : 0,
                clippingLossPct: parseFloat(APP.clippingLoss.toFixed(1)),
                clippingEvents: APP.clippingEvents.length,
                energyBalance: { ...eb },
                selfConsumptionPct: eb.totalProduction > 0 ? parseFloat((eb.selfConsumed / eb.totalProduction * 100).toFixed(1)) : 0,
                gridIndependencePct: ba ? parseFloat(ba.gridIndependencePct.toFixed(1)) : 0,
                annualSavings: ba ? parseFloat(ba.economic.annualSavings.toFixed(2)) : 0,
                overnightCoverage: ba ? `${ba.overnight.nightsCovered}/${ba.overnight.nightsTotal}` : 'N/A',
                roundTripEfficiencyPct: ba ? parseFloat((ba.efficiency.effectiveRoundTrip * 100).toFixed(1)) : 0,
                totalBatteryLossesKwh: ba ? Math.round(ba.efficiency.totalLossKwh) : 0,
                annualCycles: totalCapKwh > 0 ? parseFloat((eb.batteryCharged / totalCapKwh).toFixed(0)) : 0,
                coCompliant: eb.batteryExportedToGrid < 0.01
            },
            isRestorable: true
        };

        APP.scenarios.push(scenario);
        APP.activeScenarioIdx = APP.scenarios.length - 1;
        APP.renderScenarioManager();
        APP.log(`Scenario saved: "${scenario.name}"`, 'ok');
        return scenario;
    },

    loadScenario: (scenario) => {
        if(!scenario.isRestorable) {
            APP.log('This scenario is comparison-only (no matching site data). Cannot load into editor.', 'warn');
            return;
        }
        if(!APP.geo.length || !APP.rad.length) {
            APP.log('Load site data (JSON + DXF) before loading a scenario', 'err');
            return;
        }

        const d = scenario.design;

        // Validate panel indices
        const maxPanel = APP.geo.length - 1;
        const validStrings = d.strings.filter(s => {
            const valid = s.panels.every(p => p >= 0 && p <= maxPanel);
            if(!valid) APP.log(`Skipping string with out-of-range panels (max: ${maxPanel})`, 'warn');
            return valid;
        });

        // 1. Equipment dropdowns
        if(EQUIPMENT.panels[d.equipment.panel]) {
            document.getElementById('selPanel').value = d.equipment.panel;
        } else { APP.log(`Panel "${d.equipment.panel}" not found, keeping current`, 'warn'); }
        if(EQUIPMENT.inverters[d.equipment.inverter]) {
            document.getElementById('selInverter').value = d.equipment.inverter;
        } else { APP.log(`Inverter "${d.equipment.inverter}" not found, keeping current`, 'warn'); }
        if(d.equipment.ess && EQUIPMENT.ess[d.equipment.ess]) {
            document.getElementById('selESS').value = d.equipment.ess;
        }
        APP.updateEquipment();

        // 2. Site conditions
        document.getElementById('tempMin').value = d.siteConditions.tempMin;
        document.getElementById('tempMax').value = d.siteConditions.tempMax;
        APP.clippingThreshold = d.siteConditions.clippingThreshold;
        const clipSlider = document.getElementById('rngClipThresh');
        if(clipSlider) { clipSlider.value = Math.round(d.siteConditions.clippingThreshold * 100); }
        const clipLabel = document.getElementById('lblClipThresh');
        if(clipLabel) { clipLabel.innerText = Math.round(d.siteConditions.clippingThreshold * 100) + '%'; }
        APP.exportLimitW = (d.siteConditions.exportLimitKw || 0) * 1000;
        const expInput = document.getElementById('acExportLimit');
        if(expInput) expInput.value = d.siteConditions.exportLimitKw || 0;

        // 3. Strings
        APP.strings = validStrings.map((s, i) => ({ panels: [...s.panels], color: s.color || STRING_COLORS[i % STRING_COLORS.length] }));
        APP.currentString = [];
        APP.activeStringIdx = -1;
        APP.panelToString = {};
        APP.strings.forEach((str, sIdx) => { str.panels.forEach(pIdx => { APP.panelToString[pIdx] = sIdx; }); });

        // 4. Inverters
        APP.inverters = d.inverters.map((inv, idx) => ({
            id: idx, typeKey: inv.typeKey, name: inv.name,
            strings: [...inv.strings],
            spec: EQUIPMENT.inverters[inv.typeKey] || EQUIPMENT.inverters[d.equipment.inverter]
        }));
        APP.stringToInverter = {};
        Object.entries(d.stringToInverter).forEach(([sIdx, invIdx]) => { APP.stringToInverter[parseInt(sIdx)] = invIdx; });

        // 5. Battery config
        APP.batteryConfig = d.batteryConfig.map(b => b ? { ...b } : null);

        // 6. Home consumption
        APP.homeConsumption = { ...d.homeConsumption, profile: null };
        const annInput = document.getElementById('annualConsumption');
        if(annInput) annInput.value = d.homeConsumption.annualKwh || 0;
        const prioSel = document.getElementById('selPriorityMode');
        if(prioSel) prioSel.value = d.homeConsumption.priorityMode || 'self';
        const resSlider = document.getElementById('sliderReserve');
        if(resSlider) resSlider.value = d.homeConsumption.backupReservePct || 20;
        const resLabel = document.getElementById('lblReservePct');
        if(resLabel) resLabel.innerText = d.homeConsumption.backupReservePct || 20;
        const zipInput = document.getElementById('consumeZipCode');
        if(zipInput) zipInput.value = d.homeConsumption.zipCode || '';
        const sqftInput = document.getElementById('consumeSqFt');
        if(sqftInput) sqftInput.value = d.homeConsumption.sqFt || 0;
        if(APP.homeConsumption.enabled && APP.homeConsumption.annualKwh > 0) {
            APP.generateConsumptionProfile();
        }

        // 7. Utility rates
        APP.utilityRates = { ...d.utilityRates };
        const rStd = document.getElementById('rateStandard'); if(rStd) rStd.value = d.utilityRates.standard;
        const rPk = document.getElementById('ratePeak'); if(rPk) rPk.value = d.utilityRates.peak;
        const rOp = document.getElementById('rateOffPeak'); if(rOp) rOp.value = d.utilityRates.offPeak;

        // 8. Rebuild and re-run
        APP.recalcStrings();
        APP.renderStringList();
        APP.renderInverterConfig();
        APP.process();

        APP.activeScenarioIdx = APP.scenarios.indexOf(scenario);
        APP.renderScenarioManager();
        APP.log(`Loaded scenario: "${scenario.name}"`, 'ok');
    },

    importScenarioJSON: (file) => {
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if(data.design && data.results) {
                    // Full scenario format
                    data.isRestorable = !!(APP.geo.length && APP.rad.length);
                    APP.scenarios.push(data);
                    APP.log(`Imported scenario: "${data.name}"`, 'ok');
                } else if(data.equipment && data.strings) {
                    // Legacy exportConfig format
                    const scenario = APP.convertLegacyConfig(data);
                    scenario.isRestorable = !!(APP.geo.length && APP.rad.length);
                    APP.scenarios.push(scenario);
                    APP.log(`Imported legacy config as: "${scenario.name}"`, 'ok');
                } else {
                    APP.log('Unrecognized JSON format', 'err');
                    return;
                }
                APP.renderScenarioManager();
            } catch(err) { APP.log(`Import error: ${err.message}`, 'err'); }
        };
        reader.readAsText(file);
    },

    convertLegacyConfig: (cfg) => {
        return {
            id: crypto.randomUUID(),
            name: cfg.name || `Imported ${new Date().toLocaleTimeString()}`,
            createdAt: new Date().toISOString(),
            version: 'v11-import',
            design: {
                equipment: cfg.equipment || { panel: '', inverter: '', ess: '' },
                siteConditions: { tempMin: cfg.siteConditions?.tempMin ?? -20, tempMax: cfg.siteConditions?.tempMax ?? 45, clippingThreshold: cfg.siteConditions?.clippingThreshold ?? 1.0, exportLimitKw: cfg.exportLimitKw || 0 },
                strings: (cfg.strings || []).map((s, i) => ({ panels: (s.panels || []).map(p => p - 1), color: STRING_COLORS[i % STRING_COLORS.length] })),
                inverters: (cfg.inverters || []).map((inv, i) => ({ typeKey: APP.findInverterKey(inv.type) || '', strings: (inv.strings || []).map(s => s - 1), name: inv.name || `INV-${i+1}` })),
                stringToInverter: {},
                batteryConfig: (cfg.batteryConfig || []).map(b => b ? { essKey: b.essKey, expansions: b.expansions || 0, totalCapacityWh: (b.totalCapacityKwh || 0) * 1000, totalDcChargeW: (b.dcChargeRateKw || 0) * 1000, maxDischargeW: 0, roundTrip: 0.92 } : null),
                homeConsumption: { enabled: cfg.homeConsumption?.enabled || false, annualKwh: cfg.homeConsumption?.annualKwh || 0, inputMethod: 'annual', monthlyKwh: null, priorityMode: cfg.homeConsumption?.priorityMode || 'self', backupReservePct: cfg.homeConsumption?.backupReservePct || 20, zipCode: '', sqFt: 0, climateZone: 'mixed' },
                utilityRates: cfg.utilityRates || { standard: 0.14, peak: 0.35, offPeak: 0.10 }
            },
            results: {
                panelCount: 0, dcCapacityKw: 0, avgTSRF: 0,
                production: { independentAnnual: cfg.production?.independentAnnual || 0, stringLevelAnnual: cfg.production?.stringLevelAnnual || 0, eagleViewAnnual: cfg.production?.eagleViewAnnual || 0 },
                mismatchLossPct: parseFloat(cfg.production?.mismatchLoss) || 0,
                clippingLossPct: parseFloat(cfg.production?.clippingLoss) || 0,
                clippingEvents: cfg.production?.clippingEvents || 0,
                energyBalance: cfg.energyBalance || {},
                selfConsumptionPct: cfg.energyBalance?.totalProduction > 0 ? parseFloat((cfg.energyBalance.selfConsumed / cfg.energyBalance.totalProduction * 100).toFixed(1)) : 0,
                gridIndependencePct: cfg.batteryAnalytics?.gridIndependencePct || 0,
                annualSavings: cfg.batteryAnalytics?.annualSavings || 0,
                overnightCoverage: cfg.batteryAnalytics?.overnightCoverage || 'N/A',
                roundTripEfficiencyPct: cfg.batteryAnalytics?.roundTripEfficiency ? parseFloat((cfg.batteryAnalytics.roundTripEfficiency * 100).toFixed(1)) : 0,
                totalBatteryLossesKwh: 0, annualCycles: 0,
                coCompliant: cfg.batteryAnalytics?.coCompliant ?? true
            },
            isRestorable: false
        };
    },

    findInverterKey: (displayName) => {
        if(!displayName) return null;
        for(const [key, spec] of Object.entries(EQUIPMENT.inverters)) {
            if(spec.name === displayName) return key;
        }
        return null;
    },

    renderScenarioManager: () => {
        const list = document.getElementById('scenarioQuickList');
        const compareBtn = document.getElementById('btnCompare');
        if(!list) return;

        if(APP.scenarios.length === 0) {
            list.innerHTML = '<div style="color:#64748b; text-align:center; padding:6px; font-size:10px;">No saved scenarios</div>';
            if(compareBtn) compareBtn.disabled = true;
            return;
        }
        if(compareBtn) compareBtn.disabled = APP.scenarios.length < 2;

        list.innerHTML = APP.scenarios.map((s, i) => {
            const isActive = i === APP.activeScenarioIdx;
            const border = isActive ? 'border-left:3px solid var(--accent);' : 'border-left:3px solid transparent;';
            const kWh = s.results.production.stringLevelAnnual || s.results.production.independentAnnual || 0;
            return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px 6px; ${border} background:${isActive ? 'rgba(56,189,248,0.1)' : 'rgba(0,0,0,0.2)'}; border-radius:3px; margin-bottom:3px;">
                <div style="flex:1; min-width:0;">
                    <div style="font-weight:${isActive ? '600' : '400'}; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-size:10px;" title="${s.name}">${s.name}</div>
                    <div style="font-size:8px; color:#64748b;">${Math.round(kWh).toLocaleString()} kWh</div>
                </div>
                <div style="display:flex; gap:2px; flex-shrink:0;">
                    ${s.isRestorable ? `<button class="btn-sm btn-secondary" onclick="APP.loadScenario(APP.scenarios[${i}])" style="padding:2px 4px; font-size:8px;">Load</button>` : ''}
                    <button class="btn-sm btn-secondary" onclick="APP.downloadScenario(${i})" style="padding:2px 4px; font-size:8px;">⤓</button>
                    <button class="btn-sm" onclick="APP.deleteScenario(${i})" style="padding:2px 4px; font-size:8px; background:transparent; color:var(--err);">✕</button>
                </div>
            </div>`;
        }).join('');
    },

    downloadScenario: (idx) => {
        const s = APP.scenarios[idx];
        const blob = new Blob([JSON.stringify(s, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `scenario-${s.name.replace(/[^a-z0-9]/gi, '_')}.json`; a.click();
        URL.revokeObjectURL(url);
        APP.log(`Downloaded: "${s.name}"`, 'ok');
    },

    deleteScenario: (idx) => {
        const name = APP.scenarios[idx].name;
        APP.scenarios.splice(idx, 1);
        APP.compareSelection = APP.compareSelection.filter(i => i !== idx).map(i => i > idx ? i - 1 : i);
        if(APP.activeScenarioIdx === idx) APP.activeScenarioIdx = -1;
        else if(APP.activeScenarioIdx > idx) APP.activeScenarioIdx--;
        APP.renderScenarioManager();
        if(document.getElementById('view-scenarios')?.classList.contains('active')) APP.renderScenarioComparison();
        APP.log(`Deleted scenario: "${name}"`, 'ok');
    },

    toggleCompare: (idx) => {
        const pos = APP.compareSelection.indexOf(idx);
        if(pos >= 0) { APP.compareSelection.splice(pos, 1); }
        else if(APP.compareSelection.length < 4) { APP.compareSelection.push(idx); }
        else { APP.log('Maximum 4 scenarios for comparison', 'warn'); return; }
        APP.renderScenarioComparison();
    },

    renderScenarioComparison: () => {
        const container = document.getElementById('scenarioContent');
        if(!container) return;

        if(APP.scenarios.length === 0) {
            container.innerHTML = '<div style="color:#64748b; text-align:center; padding:50px;">Save scenarios to compare configurations.<br><br>Use <strong>Save Current</strong> in the Scenarios card on the right panel.</div>';
            return;
        }

        // Selection checkboxes
        let html = '<div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:15px; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px;">';
        html += '<span style="font-size:11px; font-weight:600; color:#94a3b8; margin-right:4px;">Compare:</span>';
        APP.scenarios.forEach((s, i) => {
            const checked = APP.compareSelection.includes(i) ? 'checked' : '';
            const active = i === APP.activeScenarioIdx ? ' ★' : '';
            html += `<label style="font-size:10px; cursor:pointer; display:flex; align-items:center; gap:3px; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;">
                <input type="checkbox" ${checked} onchange="APP.toggleCompare(${i})"> ${s.name}${active}
            </label>`;
        });
        html += '</div>';

        const selected = APP.compareSelection.map(i => APP.scenarios[i]).filter(s => s);
        if(selected.length < 2) {
            html += '<div style="color:#64748b; text-align:center; padding:30px;">Select at least 2 scenarios to compare.</div>';
            container.innerHTML = html;
            return;
        }

        // Metrics definition
        const metrics = [
            { section: 'PRODUCTION' },
            { label: 'Panel Count', key: 'panelCount', fmt: 'int', best: null },
            { label: 'DC Capacity (kW)', key: 'dcCapacityKw', fmt: 'dec1', best: null },
            { label: 'Independent kWh/yr', key: 'production.independentAnnual', fmt: 'int', best: 'max' },
            { label: 'String-Level kWh/yr', key: 'production.stringLevelAnnual', fmt: 'int', best: 'max' },
            { label: 'EagleView kWh/yr', key: 'production.eagleViewAnnual', fmt: 'int', best: 'max' },
            { section: 'LOSSES' },
            { label: 'Mismatch Loss', key: 'mismatchLossPct', fmt: 'pct1', best: 'min' },
            { label: 'Clipping Loss', key: 'clippingLossPct', fmt: 'pct1', best: 'min' },
            { label: 'Clipping Events', key: 'clippingEvents', fmt: 'int', best: 'min' },
            { section: 'ENERGY BALANCE' },
            { label: 'Self-Consumption', key: 'selfConsumptionPct', fmt: 'pct1', best: 'max' },
            { label: 'Grid Export (kWh)', key: 'energyBalance.gridExport', fmt: 'int', best: null },
            { label: 'Grid Import (kWh)', key: 'energyBalance.gridImport', fmt: 'int', best: 'min' },
            { section: 'BATTERY' },
            { label: 'Charged (kWh)', key: 'energyBalance.batteryCharged', fmt: 'int', best: null },
            { label: 'Discharged (kWh)', key: 'energyBalance.batteryDischarged', fmt: 'int', best: 'max' },
            { label: 'Losses (kWh)', key: 'energyBalance.batteryLosses', fmt: 'int', best: 'min' },
            { label: 'Annual Cycles', key: 'annualCycles', fmt: 'int', best: 'min' },
            { label: 'Round-Trip Eff.', key: 'roundTripEfficiencyPct', fmt: 'pct1', best: 'max' },
            { section: 'OUTCOMES' },
            { label: 'Grid Independence', key: 'gridIndependencePct', fmt: 'pct1', best: 'max' },
            { label: 'Annual Savings', key: 'annualSavings', fmt: 'dollar', best: 'max' },
            { label: 'Overnight Coverage', key: 'overnightCoverage', fmt: 'text', best: null },
            { label: 'CO Compliant', key: 'coCompliant', fmt: 'bool', best: null }
        ];

        // Table
        html += '<div style="overflow-x:auto;">';
        html += '<table style="width:100%; border-collapse:collapse; font-size:11px; color:#cbd5e1;">';
        // Header
        html += '<thead><tr><th style="padding:8px; text-align:left; border-bottom:2px solid #334155; min-width:160px; color:#94a3b8;">Metric</th>';
        selected.forEach((s) => {
            const sIdx = APP.scenarios.indexOf(s);
            const isActive = sIdx === APP.activeScenarioIdx;
            html += `<th style="padding:8px; text-align:right; min-width:140px; border-bottom:2px solid ${isActive ? 'var(--accent)' : '#334155'};">
                <div style="font-weight:600; color:${isActive ? 'var(--accent)' : 'var(--text)'};">${s.name}${isActive ? ' ★' : ''}</div>
                <div style="font-size:8px; color:#64748b; font-weight:normal; margin-top:2px;">${s.design.equipment.panel.replace(/_/g,' ')}</div>
                ${s.isRestorable ? `<button class="btn-sm btn-secondary" onclick="APP.loadScenario(APP.scenarios[${sIdx}])" style="margin-top:3px; padding:2px 6px; font-size:8px;">Load</button>` : '<span style="font-size:8px; color:#64748b;">View only</span>'}
            </th>`;
        });
        html += '</tr></thead><tbody>';

        // Rows
        metrics.forEach(m => {
            if(m.section) {
                html += `<tr><td colspan="${selected.length + 1}" style="background:rgba(56,189,248,0.08); font-weight:700; font-size:10px; color:var(--accent); padding:8px 6px; text-transform:uppercase; letter-spacing:1px;">${m.section}</td></tr>`;
                return;
            }
            const values = selected.map(s => {
                const keys = m.key.split('.');
                let val = s.results;
                keys.forEach(k => { val = val?.[k]; });
                return val;
            });
            let bestIdx = -1;
            if(m.best) {
                const numVals = values.map(v => typeof v === 'number' ? v : null);
                const validNums = numVals.filter(v => v !== null);
                if(validNums.length > 0) {
                    const target = m.best === 'max' ? Math.max(...validNums) : Math.min(...validNums);
                    bestIdx = numVals.indexOf(target);
                }
            }
            html += `<tr style="border-bottom:1px solid rgba(51,65,85,0.4);"><td style="padding:6px; color:#94a3b8;">${m.label}</td>`;
            values.forEach((v, i) => {
                const isBest = i === bestIdx;
                const style = isBest ? 'color:var(--success); font-weight:600;' : '';
                let display = '';
                if(v === undefined || v === null) { display = '—'; }
                else switch(m.fmt) {
                    case 'int': display = typeof v === 'number' ? Math.round(v).toLocaleString() : String(v); break;
                    case 'dec1': display = typeof v === 'number' ? v.toFixed(1) : String(v); break;
                    case 'pct1': display = typeof v === 'number' ? v.toFixed(1) + '%' : String(v); break;
                    case 'dollar': display = typeof v === 'number' ? '$' + v.toFixed(0) : String(v); break;
                    case 'bool': display = v === true ? '✓ Yes' : v === false ? '✗ No' : String(v); break;
                    case 'text': display = String(v); break;
                    default: display = String(v);
                }
                html += `<td style="text-align:right; padding:6px; ${style}">${display}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody></table></div>';

        // Export button
        html += '<div style="margin-top:15px;"><button class="btn-sm btn-secondary" onclick="APP.exportComparisonCSV()">Export Comparison CSV</button></div>';

        container.innerHTML = html;
    },

    exportComparisonCSV: () => {
        const selected = APP.compareSelection.map(i => APP.scenarios[i]).filter(s => s);
        if(selected.length < 2) { APP.log('Select at least 2 scenarios to export', 'warn'); return; }

        const metrics = [
            { label: 'Panel Count', key: 'panelCount' },
            { label: 'DC Capacity (kW)', key: 'dcCapacityKw' },
            { label: 'Independent kWh/yr', key: 'production.independentAnnual' },
            { label: 'String-Level kWh/yr', key: 'production.stringLevelAnnual' },
            { label: 'EagleView kWh/yr', key: 'production.eagleViewAnnual' },
            { label: 'Mismatch Loss %', key: 'mismatchLossPct' },
            { label: 'Clipping Loss %', key: 'clippingLossPct' },
            { label: 'Clipping Events', key: 'clippingEvents' },
            { label: 'Self-Consumption %', key: 'selfConsumptionPct' },
            { label: 'Grid Export kWh', key: 'energyBalance.gridExport' },
            { label: 'Grid Import kWh', key: 'energyBalance.gridImport' },
            { label: 'Battery Charged kWh', key: 'energyBalance.batteryCharged' },
            { label: 'Battery Discharged kWh', key: 'energyBalance.batteryDischarged' },
            { label: 'Battery Losses kWh', key: 'energyBalance.batteryLosses' },
            { label: 'Annual Cycles', key: 'annualCycles' },
            { label: 'Round-Trip Efficiency %', key: 'roundTripEfficiencyPct' },
            { label: 'Grid Independence %', key: 'gridIndependencePct' },
            { label: 'Annual Savings $', key: 'annualSavings' },
            { label: 'Overnight Coverage', key: 'overnightCoverage' },
            { label: 'CO Compliant', key: 'coCompliant' }
        ];

        let csv = 'Metric,' + selected.map(s => `"${s.name}"`).join(',') + '\n';
        metrics.forEach(m => {
            const vals = selected.map(s => {
                const keys = m.key.split('.');
                let v = s.results;
                keys.forEach(k => { v = v?.[k]; });
                return v !== undefined && v !== null ? v : '';
            });
            csv += `"${m.label}",${vals.join(',')}\n`;
        });

        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'scenario-comparison.csv'; a.click();
        URL.revokeObjectURL(url);
        APP.log('Comparison CSV exported', 'ok');
    }
};

// Initialize on load
window.onload = APP.init;
window.onerror = function(m,u,l) {
    document.getElementById('log').innerHTML += `<div class="ln-err">Error: ${m} (Line ${l})</div>`;
};
</script>
</body>
</html>
